bedtime story operating systemsbedtime story operating systemsbedtime story operating system nobody 2015 author like take discredit writing book authenticity originality content book debatable book updated regularly make sure reading latest version depiction dinosaur popular medium grossly flawed book printed environmentfriendly paper content 1 introduction operating system 1 2 process process scheduling 5 3 process synchronization 15 4 deadlock 21 5 memory management 27 6 virtual memory management 33 7 storage management 39 8 io management b system protection security 43unit 1 introduction operating system computer general purpose device execute sequence instruction presented formal format perform numerical calculation task revise block diagram computer concept memory hierarchy computer science study computer system computing process read newell perlis j simon h 1967 computer science science engineering science 1673795 13731374 computer hardware collection physical element computer system computer software collection program stored executed computer system application software performs specific task user system software operates control computer system provides platform run application software operating system piece software manages resource computer system hardware software provides environment user execute hisher program convenient efficient manner operating system exist offer reasonable way solve problem creating usable computer system operating system manages computer hardware facilitates execution application program act intermediary user computer hardware designed convenient efficient user application program operating system computer hardware operating system provides mean proper use resource operation computer system design goal convenience ease use personal computer efficiency proper resource allocation high performance computer energy conservation handheld device minimal user interference embedded devices2 bedtime story operating system operating system act resource allocator control program first operating system atlas manchester univ late 1950s early 1960s evolved control program type operating system single process operating system m do 1981 batchprocessing operating system atlas manchester univ late 1950s early 1960s multiprogramming operating system dijkstra early 1960s multitasking operating system ct mit early 1960s multiprogramming increase cpu utilization keeping multiple job code data memory cpu always one execute job 1 job 2 job 3 operating system multitasking logical extension multiprogramming cpu executes multiple task switching among switching fast requires interactive handson computer user directly interact computer response time minimal kernel part operating system interacts directly hardware performs crucial task microkernel much smaller size conventional kernel support core operating system functionality shell also known command interpreter part operating system receives command user get executed system call mechanism using user program request service kernel permission perform user program typically permission perform operation like accessing io device communicating program user program invokes system call requires service system call provide interface program operating system system call different type eg fork exec getpid getppid wait exit dualmode operation user mode kernel mode supervisor mode system mode privileged mode mode bit 0 kernel 1 user request using system callan introduction operating system 3 duty operating system process management creating deleting user system process suspending resuming process interprocess communication process synchronization deadlock handling memory management keeping track part memory used job allocating deallocating memory space storage management file system management creating deleting manipulating file directory mass storage management free space management storage allocation disk scheduling caching inputoutput management operating system service helpful user user interface cuishell gui program execution io operation file system manipulation communication error detection helpful system resource allocation accounting protection security operating system structure monolithic m do unix linux layered microkernel mach minix realtime operating system rtos welldefined fixed time constraint met system fail rtos used rigid time constraint placed operation process flow data4 bedtime story operating system rtos often used control device dedicated application hard soft rtos application embedded system robotics scientific utility etc operating system smart phone cpu smart phone made much slower conserve energy booting process starting computer loading kernel computer turned poweron selftests post performed bootstrap loader resides rom executed bootstrap loader load kernel sophisticated loader device driver part operating system case study cpm m do unix linux window etc httpamturingacmorg kenneth lane thompson frederick phillips brook jr barbara liskov chapter 1 2 section 11 14 19 111 21 25 27 210unit 2 process process scheduling process program execution process unit work computer system term process job used interchangeably process comprises text section containing program code current activity represented value program counter register program stack data section containing global variable heap stack max heap data text 0 program passive entity process active entity process state defined current activity process process executes state change one process running state instant many process ready waiting process internally represented operating system process control block pcb also called task control block pcb contains information associated process process state value program counter register cpu scheduling information priority pointer scheduling queue etc accounting information process id cpu real time used time limit etc io status information list io device allocated list open file etc6 bedtime story operating system p0 p1 executing interrupt system call idle save state pcb0 load state pcb1 executing idle interrupt system call save state pcb1 load state pcb0 idle executing process scheduling selecting one process execution ready process objective multiprogramming process running time maximize cpu utilization objective multitasking switch cpu among process frequently user interact process running meet objective process scheduler selects one available process execution scheduling queue used perform process scheduling process enters system put job queue contains process system process residing memory ready execution kept ready queue ready queue implemented linked list pcbs header containing pointer first last pcbs list process waiting particular io device called device queue device device queue queuing diagram show process migrate among various scheduling queuesprocess process scheduling 7 three type scheduler process migrates among various scheduling queue throughout lifetime operating system select process queue according criterion selection done appropriate scheduler longterm scheduler job scheduler selects process submitted user load memory longterm scheduler control degree multiprogramming represented number process memory invoked le frequently shortterm scheduler cpu scheduler selects one process memory allocates cpu shortterm scheduler invoked frequently fast longterm scheduler select proper mix cpubound process iobound process cpubound process spends time computation iobound process spends time io multitasking operating system like unix window use longterm scheduler new process put memory perusal shortterm scheduler mediumterm scheduler remove process memory competition cpu thus reducing degree multiprogramming process later reintroduced memory execution resumed scheme called swapping swapping may used improve process mix free memory uncontrollable circumstance context switching done switch process switching cpu another process requires saving state current process reloading state another process state saved reloaded pcbs contextswitch time pure overhead system useful work control switch contextswitch time depends highly hardware context switching faster risc processor overlapped register window process creation one process creating another process process called parent process child process respectively process unique id process may obtain resource either parent operating system directly8 bedtime story operating system parent process may continue executing child process may wait complete process may duplicate parent process code data may new program loaded process termination mark deletion pcb process parent process may terminate child process exceeded resource usage result needed parent process terminating operating system allow orphan process may lead cascading process termination typically kernel first process created ancestor process root process tree zombie process process terminated pcb still exists parent yet accepted return value interprocess communication reason information sharing computational speedup modularity convenience model shared memory message passing sendpmessage receiveidmessage thread smallest sequence instruction managed independently scheduler thread component process multiple thread exist within process executing concurrently share resource memory thread process share instruction executable code context value variable given moment difference process thread process typically independent thread exist part process process carry considerably state information thread whereas multiple thread within process share process state well memory resource process separate address space whereas thread share address space process interact systemprovided interprocess communication mechanism context switching thread process typically faster context switching process advantage multithreaded programming responsiveness faster execution better resource utilization easy communication parallelizationprocess process scheduling 9 execution process consists alternate cpu burst io burst starting ending cpu burst cpu scheduler invoked process switch running state waiting state condition 1 switch running state ready state condition 2 switch waiting state ready state condition 3 terminates condition 4 nonpreemptive scheduling cooperating scheduling process keep cpu terminates switch waiting state machine support nonpreemptive scheduling eg window 31x preemptive scheduling process forced leave cpu switch ready queue eg unix linux window 95 higher cpu scheduling optional condition 2 3 necessary two condition m do support multiprogramming hence cpu scheduling dispatcher module operating system give control cpu process selected cpu scheduler step switching context switching user mode jumping proper location user program dispatch latency time taken stop process start another dispatch latency pure overhead scheduling criterion cpu utilization percentage throughput number process completed per unit time turnaround time time submission completion time spent different queue time spent cpu time spent different io device waiting time time spent ready queue response time time submission first response variance response time minimal gantt chart henry gantt scheduling algorithm used select process execution several well known scheduling algorithm firstcome firstserved fcfs scheduling nonpreemptive high average waiting time convoy effect several small process may need wait large process given cpu10 bedtime story operating system exercise 1 process arrival time m cpu burst time m p1 0 24 p2 1 3 p3 2 3 calculate throughput average turnaround time average waiting time shortestjobfirst sjf scheduling process smallest next cpu burst selected fcfs break tie appropriate term shortestnextcpuburstfirst optimal implemented may predict length next cpu burst use exponential average τ αt 1ατ 0 α 1 n1 n n α 0 predicted length constant α 1 predicted length equal last actual cpu burst typically α 05 τ constant system average 0 sjf either preemptive nonpreemptive preemptive sjf shortestremainingtimefirst exercise 2 process arrival time m cpu burst time m p1 0 8 p2 1 4 p3 2 9 p4 3 5 calculate throughput average turnaround time average waiting time nonpreemptive b preemptive scheduling priority scheduling cpu allocated process highest priority priority range 0 7 say 0 representing highest lowest priority priority may depend internal factor time limit memory requirement number open file etc external factor user department etc may preemptive nonpreemptive sjf special case priority scheduling priority inversely proportional predicted next cpu burst length may cause starvation ie indefinite blocking process aging gradually increase priority process waiting long time priority inversion lowpriority process get priority highpriority process waiting itprocess process scheduling 11 exercise 3 process arrival time m cpu burst time m priority p1 0 8 7 p2 2 4 5 p3 4 6 0 highest p4 6 4 1 dispatch latency 1 m calculate cpu utilization throughput average turnaround time average waiting time nonpreemptive b preemptive scheduling round robin rr scheduling small time quantum time slice defined ready queue treated circular queue process allocated cpu one time quantum preemptive time quantum large rr behaves like fcfs time quantum small rr behaves like processor sharing rule thumb 80 cpu burst shorter time quantum exercise 4 process arrival time m cpu burst time m p1 0 18 p2 2 4 p3 4 6 p4 6 12 calculate throughput average turnaround time average waiting time time quantum 8 m b time quantum 2 m multilevel queue scheduling ready queue partitioned several queue process permanently assigned one queue queue scheduling algorithm interqueue scheduling preemptive priority scheduling rr 80 time foreground process 20 time background process fcfs rr rr fcfs fcfs12 bedtime story operating system exercise 5 process arrival time m cpu burst time m queue p1 0 18 q2 p2 2 4 q2 p3 4 6 q1 highestpriority p4 6 12 q2 q1 fcfs q2 rr time quantum 2 m interqueue preemptive priority scheduling calculate throughput average turnaround time average waiting time multilevel feedback queue scheduling allows process move queue interqueue scheduling preemptive priority scheduling process waiting long lowpriority queue may moved highpriority queue exercise 6 process arrival time m cpu burst time m p1 0 32 p2 2 10 p3 4 16 p4 6 30 calculate throughput average turnaround time average waiting time comparison cid2 first come first served simple inefficient high turnaround scheduling time waiting time response time shortest job first scheduling efficient impossible implement priority scheduling low waiting time high indefinite blocking low priority process priority process round robin scheduling efficient indefinite much context switching blocking process multilevel queue scheduling low waiting time high complex priority process multilevel feedback queue fast turnaround short complex scheduling processesprocess process scheduling 13 multiple processor scheduling multiprocessor system homogeneous heterogeneous cpu scheduling approach asymmetric multiprocessing one processor performs scheduling symmetric multiprocessing processor selfscheduling eg linux support symmetric multiprocessing processor affinity high cost invalidating repopulating cache migration process one processor another avoided attempt made keep process given processor hard soft affinity load balancing attempt keep processor equally loaded pull migration push migration combination symmetric system counteracts benefit processor affinity chapter 3 5 section 31 34 41 42 51 5414 bedtime story operating systemsunit 3 process synchronization cooperating process one affect affected process executing system p0 p1 r1 cid3 r2 cid3 r1 cid3 r1 1 r2 cid3 r2 1 cid3 r1 cid3 r2 initially 10 p0 r1 10 p1 r2 10 p0 r1 11 p1 r2 9 p0 11 p1 9 race condition situation several process access manipulate data concurrently outcome execution depends particular order access take place avoid situation must ensured one process manipulate data given time done process synchronization critical section problem defined follows n process viz p p p p 0 1 2 n1 process section code called critical section process change common variable file problem ensure one process executing critical section process execute critical section critical section preceded entry section process seek permission process critical section followed exit section remaining code called remainder section entry section critical section exit section remainder section true16 bedtime story operating system solution critical section problem must satisfy following property mutual exclusion progress process critical section process want enter critical section process entry section exit section decide process enter critical section next selection postponed indefinitely bounded waiting limit number time process allowed enter critical section process made request enter critical section request granted petersons solution 2 process shared variable int turn boolean flag2 code p flagi true turn j flagj turn j critical section flagi false remainder section true prove petersons solution satisfy three property critical section problem also solved dedicated hardware semaphore integer variable apart initialization accessed two atomic operation called wait signal wait signal 0 busy waiting one process access semaphore time binary semaphore also called mutex lock used implement solution critical section problem multiple process initialized 1 wait mutex critical section signal mutex remainder section true counting semaphore used control access resource multiple instance initialized nprocess synchronization 17 semaphore may lead indefinite wait starvation deadlock p0 p1 wait wait q wait q wait signal signal q signal q signal producer consumer problem bounded buffer problem number buffer n semaphore mutex 1 access buffer empty n full 0 producer consumer produce item wait full wait empty wait mutex wait mutex remove item buffer add item buffer signal mutex signal mutex signal empty signal full consume item true true reader writer problem shared data int readcount 0 semaphore mutex 1 wrt 1 writer reader wait wrt wait mutex write readcount signal wrt readcount 1 true wait wrt signal mutex read wait mutex readcount readcount 0 signal wrt signal mutex true dining philosopher problem18 bedtime story operating system semaphore chopsticks5 initialized 1 pi wait chopsticki wait chopsticki15 eat signal chopsticki signal chopsticki15 think true philosopher get hungry simultaneously deadlock monitor highlevel process synchronization construct one process active within monitor time monitor type present set programmer defined operation provided mutual exclusion within monitor monitor variable condition type accessed wait signal operation operation xwait mean process making operation suspended another process invokes xsignal operation xsignal resume exactly one suspended process effect none syntax monitor monitor_name shared variable declaration initialization_code procedure p1 procedure pn solution dining philosopher problem using monitor monitor dp enum thinking hungry eating state5 condition self 5process synchronization 19 initialization_code int i0 5 statei thinking void test int statei45eating stateihungry statei15eating statei eating selfisignal void pickup int statei hungry testi stateieating selfiwait void putdown int statei thinking testi45 test left neighbor testi15 test right neighbor pi dppickupi eat dpputdowni chapter 6 section 61 6720 bedtime story operating systemsunit 4 deadlock multiprogramming system several process may compete finite number resource process request resource resource available time process enters waiting state sometimes process wait indefinitely resource requested held similar waiting process deadlock situation two process waiting indefinitely resource requested held one another resource partitioned several type several identical instance eg memory space register io device etc process request instance resource type allocation one instance resource type satisfy process process utilizes resource following sequence request cid4 use cid4 release necessary condition deadlock mutual exclusion one nonsharable resource hold wait process holding resource waiting resource preemption resource preempted circular wait set p0 p1 p2 pn exist p0 waiting resource held p1 p1 waiting resource held p2 pn waiting resource held p0 circular wait implies hold wait resource allocation graph request edge assignment edge cycle may deadlock necessary sufficient condition cycle deadlock resource type one instance cycle implies deadlock necessary sufficient condition resource type cycle one instance deadlock necessary sufficient condition method handling deadlock deadlock prevention ensure least one necessary condition occurrence deadlock hold22 bedtime story operating system deadlock avoidance process informs operating system resource require lifetime operating system allocates resource process sequence lead deadlock deadlock detection recovery deadlock handling mechanism deadlock infrequent may year deadlock handling expensive eg window linux etc deadlock prevention 1 mutual exclusion mutual exclusion necessary nonsharable resource like printer speaker mutual exclusion prevented sharable resource like readonly file 2 hold wait ensure process request resource holding resource protocol 1 request get resource beginning protocol 2 release current resource requesting resource disadvantage low resource utilization starvation process requiring several resource 3 preemption process request resource allocated right resource process holding preempted resource saved later restored register file resource preempted printer 4 circular wait arrange resource type r1 r2 r3 rm protocol 1 request resource increasing order protocol 2 process request ri must release rj ji instance resource type allocated together prove protocol prevent deadlock disadvantage low resource utilization reduced throughput deadlock avoidance safe state one system allocate resource process maximum order still avoid deadlock system safe state safe sequence sequence process p1 p2 p3 pn safe pi resource pi may still request satisfied currently available resource plus resource held pj ji pi may need wait one pjs deadlock safe unsafe banker algorithm used implement deadlock avoidance algorithm used bank ensure bank never allocates available money way could longer satisfy need client new process must declare maximum number instance resource type may need number exceed total number instance resource type systemdeadlocks 23 process request set resource system must determine whether allocating resource leave system safe state yes resource may allocated process process must wait till process release enough resource n process resource type data structure availablem currently available instance maxnxm maximum demand allocationnxm currently allocated neednxm max allocation data structure may vary size time pi maxi allocationi needi safety algorithm check system safe state 1 let workm finishn vector work available finishi false 0 1 2 n1 2 find finishi false needi work exists go step 4 3 work work allocationi finishi true go step 2 4 finishi true 0 1 2 n1 safe state else unsafe state time complexity omxn2 resourcerequest algorithm check request safely granted pi requesting resource requestm request 1 request needi error 2 request available wait 3 pretend allocate request available available request allocationi allocationi request needi needi request resultant state safe resource actually allocated else value available allocationi needi restored previous value time complexity om exercise 1 system four process viz p1 p4 three resource type system safe state available max 0 1 1 allocation 0 0 1 following request 6 2 4 4 2 3 cid11 1 1cid4 cid5 cid12 cid5 cid12 4 3 5 3 3 3 granted 1 2 1 0 2 1 request p3 b request p2 cid11 0 1cid4 cid11 0 1cid424 bedtime story operating system solution resourcerequest algorithm request 1 0 1 available 1 1 1 need 0 1 0 2 0 1 cid5 cid12 1 0 2 since request need3 request available pretend allocate resource 1 0 0 available 0 1 0 allocation 0 0 1 need 0 1 0 4 2 3 2 0 1 cid5 cid12 cid5 cid12 4 3 4 0 0 1 safety algorithm 0 2 1 1 0 0 initially work 0 1 0 finish f f f f p1 selected work 0 1 1 finish f f f p3 selected work 4 4 5 finish f f p4 selected work 4 6 6 finish f p2 selected work 8 8 9 finish safe sequence p1 p3 p4 p2 safe state request granted b resourcerequest algorithm request 1 0 1 available 1 1 1 need 0 1 0 2 0 1 cid5 cid12 1 0 2 since request need2 request available pretend allocate resource 1 0 0 available 0 1 0 allocation 0 0 1 need 0 1 0 5 2 4 1 0 0 cid5 cid12 cid5 cid12 3 3 3 1 0 2 safety algorithm 0 2 1 1 0 0 initially work 0 1 0 finish f f f f p1 selected work 0 1 1 finish f f f unsafe state request granted deadlock detection resource type single instance detect deadlock using waitfor graph cycle waitfor graph denotes deadlock process cycle deadlocked time complexity cycle detection algorithm on2deadlocks 25 modification banker algorithm used detect deadlock system resource type multiple instance requestnxm represents request 1 let workm finishn vector work available 0 1 2 n1 allocationi 0 finishi false else finishi true 2 find finishi false requesti work exists go step 4 3 work work allocationi finishi true go step 2 4 finishi false deadlock pi deadlocked time complexity omxn2 often invoke deadlock detection algorithm fixed time interval cpu utilization fall recovery deadlock process termination abort deadlocked process abort one process time deadlock broken resource preemption selecting victim rollback starvation chapter 7 section 71 7726 bedtime story operating systemsunit 5 memory management multistep processing user program source program variable name compiler assembler compile time object module linker object module load module relocatable address load time loader system library execution time process memory absolute address runtime memory management unit hardware mmu cpu logical address base physical address register swapping swapout swapin priority scheduling rollout rollin relocation helpful contiguous memory allocation static divide memory fixedsized block allocate one block process number partition control degree multiprogramming dynamic allocate available space process keep track hole strategy firstfit bestfit worst fit worstfit strategy result large leftover hole reusable contiguous memory allocation lead external fragmentation may enough memory left accommodate process scattered solution compaction costly paging noncontiguous memory allocation scheme page size frame size28 bedtime story operating system page frame page offset displacement page size 512 b 16 mb advantage size process independent page size external fragmentation disadvantage internal fragmentation research topic dynamic page size process allocated page table page table stored memory page table base register ptbr point page table changing page table requires changing value register thus reducing context switch time one readwrite operation requires two memory accessesmemory management 29 transition lookaside buffer tlb dedicated fast hardware associative memory search content effective access time hit ratio x tlb access time memory access time 1 hit ratio x tlb access time 2 x memory access time page table entry may readonly bit validinvalid bit invalid denotes page belongs another process shared page reentrant code pure code nonselfmodifying code changed execution page common multiple process shared contain reentrant code ed1 ed1 ed1 ed1 ed2 ed2 ed2 ed2 cid4 ed3 ed3 ed3 ed3 data1 data1 data2 data3 data2 p1 p2 p3 data3 hierarchical page table twolevel paging threelevel paging p1 p2 p3 second outer page table first outer page table inner page table many memory accesses30 bedtime story operating system hashed page table hashed value used virtual page number entry hash table linked list element hash location avoid collision element three field virtual page number frame number pointer next element list inverted page table one centralized table entry form pid p difficult implement shared page segmentation memory management scheme linear memory logically partitioned segment unique purpose address segment_number offset process may segment storing part code data typical program following segment code c data d stack s extra e typically hardware support use limited number segment given timememory management 31 many processor use segmentation paging eg intel pentium us segmentation paging 16 k segment per process process access 6 segment time segment 4 gb page size 4 kb 4 mb chapter 8 section 81 8632 bedtime story operating systemsunit 6 virtual memory management virtual memory technique allows execution process completely memory allows execution program larger memory allows higher degree multiprogramming demand paging approach implement virtual memory page loaded memory cpu want access page cpu want access loaded use program called lazy swapper also known pager v v v v logical page table disk memory physical memory v valid page memory invalid page memory cpu want access memoryresident page execution continues normally cpu want access page memory page fault trap occurs trap highest priority nonmaskable externalhardware interrupt step handling page fault 1 reference 2 trap operating cpu system 6 resume page 3 locate page disk table 5 update page table 4 find free frame load missing page disk memory34 bedtime story operating system pure demand paging extreme case demand paging execution process started none page memory starting fast response time low take advantage locality reference code data hardware support virtual memory already present page table disk let page fault ratio p typically 0 p 1 p cid4 0 actually effective access time 1p x memory access time p x page fault service time page replacement process replacing one page another memory free frame load page memory free frame 1 save content page currently memory disk 2 load new page 3 update page table avoid saving unmodified page use modify bit dirty bit require page replacement algorithm frame allocation algorithm evaluate algorithm running particular string memory reference calculating number page fault string memory reference called reference string artificially generated random number generator eg 0 1 0 3 5 6 1 0 typical response number page fault number frame page replacement algorithm 1 fifo page replacement algorithm need note time queue required simple performance good show beladys anomaly eg reference string 7 0 1 2 0 3 0 4 2 3 0 3 2 1 2 0 1 7 0 1 frame 3 page fault 15virtual memory management 35 beladys anomaly number page fault increase number frame allocated eg reference string 1 2 3 4 1 2 5 1 2 3 4 5 frame 3 page fault 9 frame 4 page fault 10 2 optimal page replacement algorithm replace page used longest period time lowest page fault rate beladys anomaly need future knowledge reference string hence impossible implement used comparison eg 9 page fault 3 leastrecently used lru page replacement algorithm replace leastrecently used page beladys anomaly implemented using counter stack eg 12 page fault implementation lru page replacement algorithm using counter page table time use field logical clock incremented every memory reference reference made page time use set current reading logical clock lru page minimum time use value search replace logical clock must overflow implementation lru page replacement algorithm using stack maintain stack page number referenced page referenced remove stack put top lru page bottom need search suitable softwaremicrocode implementation lru page replacement algorithm requires substantial hardware support stack algorithm suffer beladys anomaly page replacement algorithm stack algorithm show page memory n frame always subset page memory memory n1 frame lru page replacement algorithm n frame n recently used page memory n1 frame n1 recently used page memory hence stack algorithm 4 lru approximation page replacement algorithm system provide support necessary lru page replacement algorithm however system reference bit page table entry initially reference bit cleared 0 page referenced reference bit set 136 bedtime story operating system 4a additionalreferencebits page replacement algorithm 8bit shift register page table entry fixed time interval shift register rightshifted reference bit filling msb lru page minimum shift register value shift register vale may unique swap tied page use fifo break tie 4b second chance page replacement algorithm like fifo however reference bit 1 replace page clear reference bit frequently used page never replaced eg 11 page fault 4c enhanced second chance page replacement algorithm principle modified page good candidate replacement use reference bit modify bit ordered pair class 00 01 10 11 replace page lowest nonempty class fifo may require multiple iteration queue 5 counting based page replacement algorithm counter page least frequently used lfu page replacement algorithm frequently used mfu page replacement algorithm expensive performance good allocation frame minimum number frame otherwise many page fault frame allocation algorithm equal allocation proportional allocation proportional virtual memory process local page replacement process control page fault rate global page replacement better throughput commonly used thrashing situation system spending time servicing page fault executing process number frame need store page active use page fault frequently since page memory active use page replaced needed bring cpu utilization system load process memory order increase degree multiprogramming trigger chain reaction page fault situation cpu utilization diminishes due high paging activity called thrashingvirtual memory management 37 avoiding thrashing workingset model based locality reference working set process page referenced recent reference eg 10 reference string 2 6 1 5 7 7 7 7 5 1 6 2 3 4 1 2 3 4 4 3 4 3 3 4 4 4 3 3 w workingset size p total demand frame σ w let number frame thrashing swap one process keep degree multiprogramming high possible optimizes cpu utilization keeping track workingsets difficult page fault frequency chapter 9 section 91 92 94 9638 bedtime story operating systemsunit 7 storage management hard disk common online storage medium operating system abstract physical property storage device define logical storage file file named collection related information recorded secondary storage file smallest allotment logical secondary storage data written secondary storage unless within file file store code data file format magic number provide efficient convenient access disk operating system imposes file system allow data stored located retrieved easily design issue file system look user map logical file onto physical disk file system typically implemented multileveled system application program logical file system manages metadata logical block address file organization module allocation management free space management physical block address basic file system highlevel generic command io control device driver interrupt lowlevel device specific command disk example disk address drive 1 track 2 sector 1 directory logical construct representing set file subdirectory implementing file system boot control block volume information needed boot operating system volume one volume control block volume information volume master file table volume information directory structure file control block file information file allocation method contiguous linked indexed free space management maintain freespacelist40 bedtime story operating system hard disk provide bulk storage modern computer disk platter flat circular shape bit stored magnetically platter readwrite head fly platter arm move head together surface platter divided circular track track subdivided sector set track one arm position consist cylinder thousand cylinder disk hundred sector track outermost cylinder denoted cylinder 0 motor rotates disk high speed transfer rate rate data transferred bus disk seek time time taken move arm cylinder rotational latency time taken rotate disk head come sector positioning time random access time seek time rotational latency performance disk depends transfer rate positioning time disk addressed large onedimensional array logical block block smallest unit transfer onedimensional array logical block mapped onto physical sector sequence cylinder outermost cid4 innermost track top cid4 bottom sector storage uniform bit density sector outer track nonuniform bit density number sector track bandwidth disk number byte transferred time elapsed first request last service disk scheduling try improve access time bandwidth disk scheduling algorithm first come first served fcfs scheduling shortestseektimefirst sstf scheduling scan scheduling elevator algorithm cscan scheduling look scheduling clook schedulingstorage management 41 disk formatting physical formatting lowlevel formatting fill disk special data structure sector data structure header data area trailer contains sector number error correcting code etc logical formatting creates file system increase efficiency file system group block form chunk operating system allows program perform raw io eg large database bad block formed sector become defective logical formatting informs file system ignore chapter 10 12 section 101 103 111 112 114 115 121 122 124 12542 bedtime story operating systemsunit 8 io management b system protection security two main responsibility computer processing io process perform io minimal processing io device vary widely function speed io subsystem kernel separate rest kernel complexity managing io device device driver provide uniform device access interface io subsystem kernel kernel io subsystem software device driver 1 device driver 2 device driver n device controller 1 device controller 2 device controller n hardware device 1 device 2 device n type device storage device disk usb drive transmission device modem humaninterface device keyboard mouse display specialized device microscope telescope case flight control computer hardware port connection point device connected bus set wire transfer data control information controller control port device io port consists status register control register datain register dataout register mode performing io polling busywaiting interrupt dma burst mode cycle stealing mode direct virtual memory access dvma complementary device teletype keyboard display photocopier scanner printer virtual device pdf printer property device 44 bedtime story operating system characterstream versus block sequential access versus random access synchronous versus asynchronous sharable versus dedicated speed readonly writeonly readwrite service provided io subsystem io scheduling buffering caching spooling spool buffer hold output device like printer accept interleaved data stream error handling io protection protection internal genuine error security external intentional threat operating system implement protection provide support security object hardware software object domain specification resource process access access matrix object o1 o2 o3 o4 domain d1 r r d2 rw r rw d3 r e switch switch domain copy transfer copy limited copy unlimited object o1 o2 o3 o4 d1 d2 d3 domain d1 r r d2 rw r rw d3 r e implementation access matrix access matrix sparse global table ordered triple domain object right access list object column access matrix blank entity may discarded capability list domainsa io management b system protection security 45 row access matrix process able modify capability list threat trojan horse attractive harmless cover program harmful hidden program used virus carrier trap door hidden door logic bomb initiate attack specific situation virus selfreplicating infectious modify destroy file linux susceptible virus allow modifying executable program worm infection program spread network hook 1 attack 2 request worm worm 3 copy infected system target system type computer virus fileparasitic appends file bootmemory infects boot sector macro written highlevel language like vb affect m office file source code search modifies source code polymorphic change copying time encrypted encrypted virus decrypting code stealth avoids detection modifying part system used detect like read system call tunneling installs interrupt service routine device driver multipartite infects multiple part system chapter 13 17 18 section 131 134 174 175 182 18346 bedtime story operating systemslast revised 1 april 2016