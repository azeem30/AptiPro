r u c u r e n l g r h dsa annotated reference example granville barne luca del tongodata structure algorithm annotated reference example first edition copyright cid176c granville barnett luca del tongo 2008this book made exclusively available dotnetslackers httpdotnetslackerscom place net article news leading mind software industrycontents 1 introduction 1 11 book isnt 1 12 assumed knowledge 1 121 big oh notation 1 122 imperative programming language 3 123 object oriented concept 4 13 pseudocode 4 14 tip working example 6 15 book outline 6 16 testing 7 17 get code 7 18 final message 7 data structure 8 2 linked list 9 21 singly linked list 9 211 insertion 10 212 searching 10 213 deletion 11 214 traversing list 12 215 traversing list reverse order 13 22 doubly linked list 13 221 insertion 15 222 deletion 15 223 reverse traversal 16 23 summary 17 3 binary search tree 19 31 insertion 20 32 searching 21 33 deletion 22 34 finding parent given node 24 35 attaining reference node 24 36 finding smallest largest value binary search tree 25 37 tree traversal 26 371 preorder 26 i372 postorder 26 373 inorder 29 374 breadth first 30 38 summary 31 4 heap 32 41 insertion 33 42 deletion 37 43 searching 38 44 traversal 41 45 summary 42 5 set 44 51 unordered 46 511 insertion 46 52 ordered 47 53 summary 47 6 queue 48 61 standard queue 49 62 priority queue 49 63 double ended queue 49 64 summary 53 7 avl tree 54 71 tree rotation 56 72 tree rebalancing 57 73 insertion 58 74 deletion 59 75 summary 61 ii algorithm 62 8 sorting 63 81 bubble sort 63 82 merge sort 63 83 quick sort 65 84 insertion sort 67 85 shell sort 68 86 radix sort 68 87 summary 70 9 numeric 72 91 primality test 72 92 base conversion 72 93 attaining greatest common denominator two number 73 94 computing maximum value number specific base consisting n digit 74 95 factorial number 74 96 summary 75 ii10 searching 76 101 sequential search 76 102 probability search 76 103 summary 77 11 string 79 111 reversing order word sentence 79 112 detecting palindrome 80 113 counting number word string 81 114 determining number repeated word within string 83 115 determining first matching character two string 84 116 summary 85 algorithm walkthrough 86 a1 iterative algorithm 86 a2 recursive algorithm 88 a3 summary 90 b translation walkthrough 91 b1 summary 92 c recursive v iterative solution 93 c1 activation record 94 c2 problem recursive nature 95 c3 summary 95 testing 97 d1 constitutes unit test 97 d2 write test 98 d3 seriously view test suite 99 d4 three 99 d5 structuring test 99 d6 code coverage 100 d7 summary 100 e symbol definition 101 iiipreface every book story came one different although would lying said development somewhat impromptu put simply book result series email sent back forth two author development library net framework name omission subtitle course conversation started something like dont create aesthetically pleasing way present pseudocode week new presentation style fact grown pseudocode listing chunk text describing data structure algorithm question work various thing point thought heck let make thing book summer 2008 began work book side side actual library implementation started writing book thing sure respect book structured 1 alwaysmakeexplanationsassimpleaspossiblewhilemaintainingamoder atelyfinedegreeofprecisiontokeepthemoreeagermindedreaderhappy 2 injectdiagramstodemystifyproblemsthatareevenmoderatlychallenging tovisualiseandsowecouldrememberhowourownalgorithmsworked looking back finally 3 presentconciseandselfexplanatorypseudocodelistingsthatcanbeported easily mainstream imperative programming language like c c java key factor book associated implementation algorithm unless otherwise stated designed u using theory algorithm question guideline eternally grateful original creator therefore may sometimes turn worse normal implementationsand sometimes two fellow opinion choice great thing read book read several others subject use see fit anything implementing version algorithm question throughthisbookwehopethatyouwillseetheabsolutenecessityofunder standing data structure algorithm use certain scenario project especially concerned performance apply even greater emphasis realtime system selection wrong data structure algorithm cause great deal performance pain ivv thereforeitisabsolutelykeythatyouthinkabouttheruntimecomplexityand space requirement selected approach book explain theoreticalimplications consider forum good reason compiler different work one c compiler may amazing optimisation phase specifically targeted recursion another may ex ample course example would surprised many subtle difference compiler difference may make fast algorithm slow vice versa could also factor concern language target virtual machine leaving actual various implementation issue given know lan guages compiler much better uswell case resulted concise book focus think key issue one final note never take word others gospel verify feasibly verified make mind wehopeyouenjoyreadingthisbookasmuchaswehaveenjoyedwritingit granville barnett luca del tongoacknowledgements writing short book fun rewarding experience would like thank particular order following people helped u writing book sonu kapoor generously hosted book released first draft received thirteen thousand downloads without generosity book wouldnot havebeen ableto reachso manypeople jon skeetprovidedus alarming number suggestion throughout eternally grateful jon also edited book well wewouldalsoliketothankthosewhoprovidedtheoddsuggestionviaemail u feedback listened doubt see content influenced suggestion special thank also go helped publicise book microsofts channel 9 weekly show thanks dan many blogger helped spread word gave u audience extremely grateful thank contributed way book program ming community never cease amaze u howwilling constituentsare give time project one thank viabout author granville barnett granvilleiscurrentlyaphdcandidateatqueenslanduniversityoftechnology qutworkingonparallelismatthemicrosoftquteresearchcentre1 healso holdsadegreeincomputerscienceandisamicrosoftmvphismaininterests programming language compiler granville contacted via one two place either personal website httpgbarnettorg blog httpmsmvpscomblogsgbarnett luca del tongo luca currently studying master degree computer science flo rence main interest vary web development research field data mining computer vision luca also maintains italian blog found httpblogsugidotnetorgwetblog 1httpwwwmquterquteduau viipage intentionally left blankchapter 1 introduction 11 book isnt book provides implementation common uncommon algorithm pseudocodewhichislanguageindependentandprovidesforeasyportingtomost imperative programming language definitive book theory data structure algorithm forthemostpartthisbookpresentsimplementationsdevisedbytheauthors based concept respective algorithm based upon possible implementation differ considered norm use book alongside another subject one contains formal proof algorithm question book use abstract big oh notation depict run time complexity algorithm book appeal larger audience 12 assumed knowledge written book assumption reader beennecessaryinordertokeepthebookasconciseandapproachableaspossible assume reader familiar following 1 big oh notation 2 imperative programming language 3 object oriented concept 121 big oh notation forruntimecomplexityanalysisweusebigohnotationextensivelysoitisvital familiar general concept determine best algorithm certain scenario chosen use big oh notation reason important provides abstract measurement judge performance algorithm without using mathematical proof 1chapter 1 introduction 2 figure 11 algorithmic run time expansion figure11showssomeoftheruntimestodemonstratehowimportantitisto chooseanefficientalgorithm forthesanityofourgraphwehaveomittedcubic on3 exponential o2n run time cubic exponential algorithm shouldonlyeverbeusedforverysmallproblemsifeveravoidthemiffeasibly possible following list explains common big oh notation o1 constant theoperationdoesntdependonthesizeofitsinputeg adding node tail linked list always maintain pointer tail node linear run time complexity proportionate size n olog n logarithmic normally associated algorithm break problem smaller chunk per invocation eg searching binary search tree log n justnlogn usuallyassociatedwithanalgorithmthatbreakstheproblem intosmallerchunkspereachinvocationandthentakestheresultsofthese smaller chunk stitch back together eg quick sort on2 quadratic eg bubble sort on3 cubic rare o2n exponential incredibly rare ifyouencountereitherofthelattertwoitemscubicandexponentialthisis really signal review design algorithm prototyp ing algorithm design may intention solving problem irrespective fast work would strongly advise always review algorithm design optimise possibleparticularly loopschapter 1 introduction 3 recursive callsso get efficient run time algorithm biggest asset big oh notation give u allows u e sentially discard thing like hardware two sorting algorithm one quadratic run time logarithmic run time logarithmic algorithm always faster quadratic one data set becomes suitably large applies even former ran chine far faster latter big oh notation isolates key factor algorithm analysis growth algorithm quadratic run time grows faster one logarithmic run time generally said point n logarithmic algorithm become faster quadratic algorithm big oh notation also act communication tool picture scene meeting fellow developer within product group youarediscussingprototypealgorithmsfornodediscoveryinmassivenetworks several minute elapse two others discussed respective algorithm work give good idea fast respective algorithm result discussion tell aboutthehighlevelalgorithmdesignratherthanitsefficiency replaythescene back head time well talking algorithm design respective developer state asymptotic run time algorithm using latter approach get good general idea algorithm design also key efficiency data allows make better choice come selecting algorithm fit purpose reader may actually work product group given budget per feature feature hold budget represents permosttimebound ifyousavesometimeinonefeatureitdoesntnecessarily give buffer remaining feature imagine working application team developing routine essentially spin everything required application started everything great bos come tell start time exceed n m efficiency every algorithm invoked start example absolutely key successful product even dont budget still strive optimal solution taking quantitative approach many software development property make far superior programmer measuring one work critical success 122 imperative programming language example given pseudoimperative coding format reader must know basic imperative mainstream programming language port example effectively written book following target language mind 1 c 2 c 3 javachapter 1 introduction 4 reason explicit requirement simpleall imple mentation based imperative thinking style functional programmeryouwillneedtoapplyvariousaspectsfromthefunctionalparadigm produce efficient solution respect functional language whether haskell f ocaml etc two language listed c java target virtual machine provide various thing like security sand boxing memory management via garbage collection algorithm trivial port imple mentation language porting c must remember use pointer certain thing example describe linked list node reference next node description context managed environment c interpret reference pointer next node programmer fair amount experience respective language subtlety present sue really emphasise reader must comfortable least one imperative language order successfully port pseudo implementation book essential user familiar primitive imperative language construct reading book otherwise get lost algo rithms presented book confusing follow even experienced programmer 123 object oriented concept part book use feature specific one language particular never provide data structure algorithm work generic typesthis order make sample easy follow possible however appreciate design data structure need familiar following object oriented oo concept 1 inheritance 2 encapsulation 3 polymorphism thisisespeciallyimportantifyouareplanningonlookingatthectarget implemented 17 make extensive use oo concept listed final note also desirable reader familiar interface c target us interface throughout sorting algorithm 13 pseudocode throughout book use pseudocode describe solution part interpreting pseudocode trivial look much like abstract c c thing point 1 precondition always enforced 2 postconditionsrepresenttheresultofapplyingalgorithmatodatastruc ture dchapter 1 introduction 5 3 type parameter inferred 4 primitive language construct explicitly begun ended algorithm return type often presented post condition return type sufficiently obvious may omitted sake brevity algorithm book require parameter assign explicittypetothoseparametersthetypeisinferredfromthecontextsinwhich used operation performed upon additionally name parameter usually act biggest clue type instance n pseudoname number assume unless otherwise stated n translates integer number bit word 32bitmachinesimilarlyl isapseudonameforalistwherealistisaresizeable array eg vector thelastmajorpointofreferenceisthatwealwaysexplicitlyendalanguage construct instance wish close scope loop explicitly state end rather leaving interpretation scope areclosedtothereader whileimplicitscopeclosureworkswellinsimplecode complex case lead ambiguity thepseudocodestylethatweusewithinthisbookisratherstraightforward algorithm start simple algorithm signature eg 1 algorithm algorithmnamearg1 arg2 argn 2 n end algorithmname immediately algorithm signature list pre post condi tions 1 algorithm algorithmnamen 2 pre n value compute factorial 3 n0 4 post factorial n computed 5 n end algorithmname example describes algorithm name algorithmname take single numeric parameter n pre post condition follow algorithm signature always enforce precondition algorithm porting language choice normallywhatislistedasapreconiditioniscriticaltothealgorithmsopera tion thismaycoverthingsliketheactualparameternotbeingnullorthatthe collection passed must contain least n item postcondition mainly describestheeffectofthealgorithmsoperation anexampleofapostcondition might list sorted ascending order everything describe language independent need make mind best handle precondition example c target implemented consider nonconformance pre condition exceptional case provide message exception tell caller algorithm failed execute normallychapter 1 introduction 6 14 tip working example book get put recommend order get book work algorithm pen paper track thing like variable name recursive call etc best way work algorithm set table tablegiveeachvariableitsowncolumnandcontinuouslyupdatethesecolumns help keep track visualise mutation occurring throughout algorithm often working algorithm way intuitively map relationship data structure rather trying work value paper rest head suggest put everything paper irrespective trivial variable calculation may always point reference dealing recursive algorithm trace recommend also table record function call theyreturnto thisapproachisafarcleanerwaythandrawingoutanelaborate map function call arrow one another get large quickly simply make thing complex follow track everything simple systematic way make time studying implementation far easier 15 book outline split book two part part 1 provides discussion pseudoimplementations common uncom mon data structure part 2 providesalgorithmsofvaryingpurposesfromsortingtostringoperations reader doesnt read book sequentially beginning end chapter read independently one another suggest part 1 read chapter entirety part 2 get away reading section chapter describes algorithm interested eachofthechaptersondatastructurespresentinitiallythealgorithmscon cerned 1 insertion 2 deletion 3 searching previous list represents believe vast majority case important respective data structure reader recommend looking algorithm quickly look appendix e contains table listing various symbol usedwithinouralgorithmsandtheirmeaning onekeywordthatwewouldlike point yield think yield light return thereturnkeywordcausesthemethodtoexitandreturnscontroltothecaller whereas yield return value caller yield control return caller value return caller exhaustedchapter 1 introduction 7 16 testing data structure algorithm tested using minimised test driven development style paper flesh pseudocode algorithm transcribe test unit test satisfying one one test case progressively satisfied consider algorithm suitably tested part algorithm fairly obvious case need satisfied however many area prove complex tosatisfy withsuchalgorithmswewillpointoutthetestcaseswhicharetricky andthecorrespondingportionsofpseudocodewithinthealgorithmthatsatisfy respective case become familiar actual problem able intuitively identify area may cause problem algorithm imple mentation thisinsomecaseswillyieldanoverwhelminglistofconcernswhich hinder ability design algorithm greatly bom barded vast amount concern look overall problem andsubdividetheproblemintosmallerproblems solvingthesmallerproblems composing far easier task clouding mind many little detail type testing use implementation provided book unit test unit test contribute core piece creating somewhat stable software invite reader view appendix describes testing depth 17 get code book doesnt provide code specifically aligned however actively maintain open source project1 house c implementation allthepseudocodelisted theprojectisnameddatastructuresandalgorithms dsa found httpcodeplexcomdsa 18 final message final message reader hope digest embark reading book 1 understand algorithm work first abstract sense 2 always work algorithm paper understand achieve outcome ifyoualwaysfollowthesekeypoints youwillgetthemostoutofthisbook 1all reader encouraged provide suggestion feature request bug furtherimproveourimplementationspart data structure 8chapter 2 linked list linked list thought high level perspective series node node least single pointer next node last node case null pointer representing node linked list dsa implementation linked list always maintain head tail pointer insertion either head tail list constant time operation random insertion excluded linear operation linked list dsa following characteristic 1 insertion o1 2 deletion 3 searching three operation one stand insertion dsa chose always maintain pointer aptly reference node head tail linked list performing traditional insertion either front back linked list o1 operation exception rule performing insertion node neither head tail singly linked list node inserting somewhere middle linked list known random insertion complexity order add designated node need traverse linked list find node current predecessor traversal yield run time thisdatastructureistrivial butlinkedlistshaveafewkeypointswhichat time make attractive 1 thelistisdynamicallyresizedthusitincursnocopypenaltylikeanarray vector would eventually incur 2 insertion o1 21 singly linked list singly linked list one primitive data structure find book node make singly linked list consists value reference next node list 9chapter 2 linked list 10 figure 21 singly linked list node figure 22 singly linked list populated integer 211 insertion general people talk insertion respect linked list form implicitly refer adding node tail list use api like dsa see general purpose method addsanodetothelistyoucanassumethatyouareaddingthenodetothetail list head adding node singly linked list two case 1 head case node adding head tail list 2 simply need append node onto end list updating tail reference appropriately 1 algorithm addvalue 2 pre value value add list 3 post value placed tail list 4 n nodevalue 5 head 6 headn 7 tailn 8 else 9 tailnext n 10 tailn 11 end 12 end add example previous algorithm consider adding following se quence integer list 1 45 60 12 resulting list figure 22 212 searching searching linked list straightforward simply traverse list checking value looking value node linked list algorithmlistedinthissectionisverysimilartothatusedfortraversalin214chapter 2 linked list 11 1 algorithm containshead value 2 pre head head node list 3 value value search 4 post item either linked list true otherwise false 5 nhead 6 n cid54 nvalue cid54value 7 nnnext 8 end 9 n 10 return false 11 end 12 return true 13 end contains 213 deletion deleting node linked list straightforward case need account 1 list empty 2 node remove node linked list 3 removing head node 4 removing tail node 5 node remove somewhere head tail 6 item remove doesnt exist linked list algorithm whose case described remove node wherewithinalistirrespectiveofwhetherthenodeistheheadetc ifyouknow item ever removed head tail list create much concise algorithm case always removing front linked list deletion becomes o1 operationchapter 2 linked list 12 1 algorithm removehead value 2 pre head head node list 3 value value remove list 4 post value removed list true otherwise false 5 head 6 case 1 7 return false 8 end 9 nhead 10 nvalue value 11 headtail 12 case 2 13 head 14 tail 15 else 16 case 3 17 headheadnext 18 end 19 return true 20 end 21 nnext cid54 nnextvalue cid54value 22 nnnext 23 end 24 nnext cid54 25 nnext tail 26 case 4 27 tailn 28 end 29 case 5 conditional line 25 false 30 nnext nnextnext 31 return true 32 end 33 case 6 34 return false 35 end remove 214 traversing list traversing singly linked list traversing doubly linked list defined 22 start head list continue come across node two case follows 1 node exhausted node linked list 2 must update node reference nodenext algorithm described simple one make use simple loop check first casechapter 2 linked list 13 1 algorithm traversehead 2 pre head head node list 3 post item list traversed 4 nhead 5 n cid540 6 yield nvalue 7 nnnext 8 end 9 end traverse 215 traversing list reverse order traversing singly linked list forward manner ie left right simple asdemonstratedin214 however whatifwewantedtotraversethenodesin linked list reverse order reason algorithm perform traversal simple like demonstrated 213 need acquire reference predecessor node even though fundamental characteristic node make singly linked list make expensiveoperation foreachnodefindingitspredecessorisanonoperation sooverthecourseoftraversingthewholelistbackwardsthecostbecomeson2 figure23depictsthefollowingalgorithmbeingappliedtoalinkedlistwith integer 5 10 1 40 1 algorithm reversetraversalhead tail 2 pre head tail belong list 3 post item list traversed reverse order 4 tail cid54 5 curr tail 6 curr cid54head 7 prev head 8 prevnext cid54curr 9 prev prevnext 10 end 11 yield currvalue 12 curr prev 13 end 14 yield currvalue 15 end 16 end reversetraversal algorithm real interest using singly linked list soon see doubly linked list defined 22 make reverse list traversal simple efficient shown 223 22 doubly linked list doubly linked list similar singly linked list difference node reference next previous node listchapter 2 linked list 14 figure 23 reverse traveral singly linked list figure 24 doubly linked list nodechapter 2 linked list 15 following algorithm doubly linked list exactly listed previously singly linked list 1 searching defined 212 2 traversal defined 214 221 insertion major difference algorithm 211 need remember bind previous pointer n previous tail node n first node inserted list 1 algorithm addvalue 2 pre value value add list 3 post value placed tail list 4 n nodevalue 5 head 6 headn 7 tailn 8 else 9 nprevious tail 10 tailnext n 11 tailn 12 end 13 end add figure 25 show doubly linked list adding sequence integer defined 211 figure 25 doubly linked list populated integer 222 deletion may guessed case use deletion doubly linked list exactly defined 213 like insertion added task binding additional reference previous correct valuechapter 2 linked list 16 1 algorithm removehead value 2 pre head head node list 3 value value remove list 4 post value removed list true otherwise false 5 head 6 return false 7 end 8 valueheadvalue 9 headtail 10 head 11 tail 12 else 13 headheadnext 14 headprevious 15 end 16 return true 17 end 18 nheadnext 19 n cid54 value cid54nvalue 20 nnnext 21 end 22 ntail 23 tailtailprevious 24 tailnext 25 return true 26 else n cid54 27 npreviousnext nnext 28 nnextprevious nprevious 29 return true 30 end 31 return false 32 end remove 223 reverse traversal singlylinkedlistshaveaforwardonlydesignwhichiswhythereversetraversal algorithmdefinedin215requiredsomecreativeinvention doublylinkedlists make reverse traversal simple forward traversal defined 214 except thatwestartatthetailnodeandupdatethepointersintheoppositedirection figure 26 show reverse traversal algorithm actionchapter 2 linked list 17 figure 26 doubly linked list reverse traversal 1 algorithm reversetraversaltail 2 pre tail tail node list traverse 3 post list traversed reverse order 4 ntail 5 ncid54 6 yield nvalue 7 nnprevious 8 end 9 end reversetraversal 23 summary linked list good use unknown number item store using data structure like array would require specify size front exceeding size involves invoking resizing algorithm linear run time also use linked list remove node either head tail list maintain constant run time requires maintaining pointer node head tail list memory overhead pay operation performing many time linked list good random insertion accessing node index searching expense little memory case 4 byte would suffice readwrites could maintain count variable track many item contained list accessing primitive property constant operation need update count insertion deletion algorithm singly linked list used performing basic sertions general doubly linked list accommodating nontrivial operation linked list recommend use doubly linked list require forward backwards traversal case requirement present example consider token stream want parse recursive descent fashion sometimes backtrack order create correct parse tree scenario doubly linked list best design make bidirectional traversal much simpler quicker singly linkedchapter 2 linked list 18 listchapter 3 binary search tree binarysearchtreesbstsareverysimpletounderstand westartwitharoot node value x left subtree x contains node value x right subtree contains node whose value x node follows rule respect node left right subtrees bstsareofinterestbecausetheyhaveoperationswhicharefavourablyfast insertionlookupanddeletioncanallbedoneinolog ntime itisimportant note olog n time operation attained bst reasonably balanced tree data structure self balancing property see avl tree defined 7 following example assume unless used parameter alias root reference root node tree 23 14 31 7 17 9 figure 31 simple unbalanced binary search tree 19chapter 3 binary search tree 20 31 insertion mentioned previously insertion olog n operation provided tree moderately balanced 1 algorithm insertvalue 2 pre value passed custom type check type 3 post value placed correct location tree 4 root 5 root nodevalue 6 else 7 insertnoderoot value 8 end 9 end insert 1 algorithm insertnodecurrent value 2 pre current node start 3 post value placed correct location tree 4 valuecurrentvalue 5 currentleft 6 currentleft nodevalue 7 else 8 insertnodecurrentleft value 9 end 10 else 11 currentright 12 currentright nodevalue 13 else 14 insertnodecurrentright value 15 end 16 end 17 end insertnode insertion algorithm split good reason first algorithm non recursive check core base case whether tree empty tree empty simply create root node finish case invoke recursive insertnode algorithm simply guide u first appropriate place tree put value note stage perform binary chop either choose recurse left subtree rightbycomparingthenewvaluewiththatofthecurrentnode foranytotally ordered type value simultaneously satisfy condition place subtreeschapter 3 binary search tree 21 32 searching searchingabstisevensimplerthaninsertion thepseudocodeisselfexplanatory look briefly premise algorithm nonetheless wehavetalkedpreviouslyaboutinsertionwegoeitherleftorrightwiththe right subtree containing value x x value node inserting searching rule made little atomic one time four case consider 1 root case value bst 2 rootvalue value case value bst 3 valuerootvalue must inspect left subtree root value 4 valuerootvalue must inspect right subtree root value 1 algorithm containsroot value 2 pre root root node tree value would like locate 3 post value either located 4 root 5 return false 6 end 7 rootvalue value 8 return true 9 else valuerootvalue 10 return containsrootleft value 11 else 12 return containsrootright value 13 end 14 end containschapter 3 binary search tree 22 33 deletion removing node bst fairly straightforward four case con sider 1 value remove leaf node 2 value remove right subtree left subtree 3 value remove left subtree right subtree 4 value remove left right subtree case promote largest value left subtree also implicit fifth case whereby node removed node tree case already covered first noted possibility nonetheless course bst value may occur case first occurrence value bst removed 4 right subtree 23 left subtree 3 left subtree 14 31 right subtree 2 right subtree 7 left subtree 1 leaf node 9 figure 32 binary search tree deletion case remove algorithm given relies two helper algorithm named findparent findnode described 34 35 spectivelychapter 3 binary search tree 23 1 algorithm removevalue 2 pre value value node remove root root node bst 3 count number item bst 3 post node value removed found case yield true otherwise false 4 nodetoremove findnodevalue 5 nodetoremove 6 return false value bst 7 end 8 parent findparentvalue 9 count 1 10 root removing node bst 11 else nodetoremoveleft nodetoremoveright null 12 case 1 13 nodetoremovevalue parentvalue 14 parentleft 15 else 16 parentright 17 end 18 else nodetoremoveleft nodetoremoveright cid54 19 case 2 20 nodetoremovevalue parentvalue 21 parentleft nodetoremoveright 22 else 23 parentright nodetoremoveright 24 end 25 else nodetoremoveleft cid54 nodetoremoveright 26 case 3 27 nodetoremovevalue parentvalue 28 parentleft nodetoremoveleft 29 else 30 parentright nodetoremoveleft 31 end 32 else 33 case 4 34 largestvaluenodetoremoveleft 35 largestvalueright cid54 36 find largest value left subtree nodetoremove 37 largestvaluelargestvalueright 38 end 39 set parent right pointer largestvalue 40 findparentlargestvaluevalueright 41 nodetoremovevalue largestvaluevalue 42 end 43 count count 1 44 return true 45 end removechapter 3 binary search tree 24 34 finding parent given node purpose algorithm simple return reference pointer parent node one given value found algorithm useful especially performing extensive tree transforma tions 1 algorithm findparentvalue root 2 pre value value node want find parent 3 root root node bst 4 post reference parent node value found otherwise 5 valuerootvalue 6 return 7 end 8 valuerootvalue 9 rootleft 10 return 11 else rootleftvalue value 12 return root 13 else 14 return findparentvalue rootleft 15 end 16 else 17 rootright 18 return 19 else rootrightvalue value 20 return root 21 else 22 return findparentvalue rootright 23 end 24 end 25 end findparent special case algorithm specified value existinthebstinwhichcasewereturn callerstothisalgorithmmusttake account possibility unless already certain node specified value exists 35 attaining reference node thisalgorithmisverysimilarto34butinsteadofreturningareferencetothe parent node specified value return reference node returned value isnt foundchapter 3 binary search tree 25 1 algorithm findnoderoot value 2 pre value value node want find parent 3 root root node bst 4 post reference node value found otherwise 5 root 6 return 7 end 8 rootvalue value 9 return root 10 else valuerootvalue 11 return findnoderootleft value 12 else 13 return findnoderootright value 14 end 15 end findnode astute reader noticed findnode algorithm exactly contains algorithm defined 32 modification returning reference node true false given findnode easiest way implementing contains call findnode compare return value 36 finding smallest largest value binary search tree find smallest value bst simply traverse node left subtree bst always going left upon encounter node termi natingwhenyoufindanodewithnoleftsubtree theoppositeisthecasewhen findingthelargestvalueinthebstbothalgorithmsareincrediblysimpleand listed simply completeness thebasecaseinbothfindminandfindmaxalgorithmsiswhentheleft findmin right findmax node reference case reached last node 1 algorithm findminroot 2 pre root root node bst 3 root cid54 4 post smallest value bst located 5 rootleft 6 return rootvalue 7 end 8 findminrootleft 9 end findminchapter 3 binary search tree 26 1 algorithm findmaxroot 2 pre root root node bst 3 root cid54 4 post largest value bst located 5 rootright 6 return rootvalue 7 end 8 findmaxrootright 9 end findmax 37 tree traversal various strategy employed traverse item tree choice strategy depends node visitation order require section touch traversal dsa provides data structure derive binarysearchtree 371 preorder whenusingthepreorderalgorithmyouvisittherootfirstthentraversetheleft subtree finally traverse right subtree example preorder traversal shown figure 33 1 algorithm preorderroot 2 pre root root node bst 3 post node bst visited preorder 4 root cid54 5 yield rootvalue 6 preorderrootleft 7 preorderrootright 8 end 9 end preorder 372 postorder algorithm similar described 371 however value node yielded traversing subtrees example postorder traversal shown figure 34 1 algorithm postorderroot 2 pre root root node bst 3 post node bst visited postorder 4 root cid54 5 postorderrootleft 6 postorderrootright 7 yield rootvalue 8 end 9 end postorderchapter 3 binary search tree 27 23 23 23 14 31 14 31 14 31 7 17 7 17 7 17 9 9 9 b c 23 23 23 14 31 14 31 14 31 7 17 7 17 7 17 9 9 9 e f figure 33 preorder visit binary search tree examplechapter 3 binary search tree 28 23 23 23 14 31 14 31 14 31 7 17 7 17 7 17 9 9 9 b c 23 23 23 14 31 14 31 14 31 7 17 7 17 7 17 9 9 9 e f figure 34 postorder visit binary search tree examplechapter 3 binary search tree 29 373 inorder anothervariationofthealgorithmsdefinedin371and372isthatofinorder traversal value current node yielded traversing theleftsubtreeandtherightsubtree anexampleofinordertraversalisshown figure 35 23 23 23 14 31 14 31 14 31 7 17 7 17 7 17 9 9 9 b c 23 23 23 14 31 14 31 14 31 7 17 7 17 7 17 9 9 9 e f figure 35 inorder visit binary search tree example 1 algorithm inorderroot 2 pre root root node bst 3 post node bst visited inorder 4 root cid54 5 inorderrootleft 6 yield rootvalue 7 inorderrootright 8 end 9 end inorder one beauty inorder traversal value yielded comparison order word traversing populated bst inorder strategy yielded sequence would property x x i1chapter 3 binary search tree 30 374 breadth first traversing tree breadth first order yield value node par ticular depth tree deeper one word given depth would visit value node left right fashion would proceed d1 hade node visit example breadth first traversal shown figure 36 traditionally breadth first traversal implemented using list vector sizeablearray etctostorethevaluesofthenodesvisitedinbreadthfirstorder queue store node yet visited 23 23 23 14 31 14 31 14 31 7 17 7 17 7 17 9 9 9 b c 23 23 23 14 31 14 31 14 31 7 17 7 17 7 17 9 9 9 e f figure 36 breadth first visit binary search tree examplechapter 3 binary search tree 31 1 algorithm breadthfirstroot 2 pre root root node bst 3 post node bst visited breadth first order 4 q queue 5 root cid54 6 yield rootvalue 7 rootleft cid54 8 qenqueuerootleft 9 end 10 rootright cid54 11 qenqueuerootright 12 end 13 qisempty 14 rootqdequeue 15 else 16 root 17 end 18 end 19 end breadthfirst 38 summary abinarysearchtreeisagoodsolutionwhenyouneedtorepresenttypesthatare orderedaccordingtosomecustomrulesinherenttothattype withlogarithmic insertion lookup deletion effecient traversal remains linear many way visit node tree tree recursive data structure typically find many algorithm operate tree recursive theruntimespresentedinthischapterarebasedonaprettybigassumption binary search tree left right subtrees reasonably balanced attain logarithmic run time algorithm presented earlier true binary search tree enforce property run time operation pathologically unbalanced tree become linear tree effectively linked list later 7 examine avl tree enforces selfbalancing property help attain logarithmic run timeschapter 4 heap aheapcanbethoughtofasasimpletreedatastructurehoweveraheapusually employ one two strategy 1 min heap 2 max heap strategy determines property tree value weretochoosetheminheapstrategytheneachparentnodewouldhaveavalue child example node root tree smallest value tree opposite true max heap strategy book assume heap employ min heap strategy unless otherwise stated unlikeothertreedatastructuresliketheonedefinedin3aheapisgenerally implemented array rather series node refer ences node node conceptually however two child figure 41 show tree heap data structure 1273269 wouldberepresentedasanarray thearrayinfigure41isa result simply adding value toptobottom lefttoright fashion figure 42 show arrow direct left right child value array thischapterisverymuchcentredaroundthenotionofrepresentingatreeas array property key understanding chapter figure 43 show step step process represent tree data structure array figure 43 assume default capacity array eight usingjustanarrayisoftennotsufficientaswehavetobeupfrontaboutthe sizeofthearraytousefortheheap oftentheruntimebehaviourofaprogram unpredictable come size internal data structure soweneedtochooseamoredynamicdatastructurethatcontainsthefollowing property 1 specify initial size array scenario know upper storage limit required 2 data structure encapsulates resizing algorithm grow array required run time 32chapter 4 heap 33 figure 41 array representation simple tree data structure figure42 directchildrenofthenodesinanarrayrepresentationofatreedata structure 1 vector 2 arraylist 3 list figure 41 specify would handle adding null reference heap varies case case sometimes null value prohibited entirely case may treat smaller nonnull value indeed greater nonnull value resolve ambiguityyourselfhavingstudiedyourrequirements forthesakeofclaritywe avoid issue prohibiting null value using array need way calculate index parent node child node required expression defined follows node index 1 index12 parent index 2 2index1 left child 3 2index2 right child figure 44 represents calculation right child 12 202 b calculates index parent 3 312 41 insertion designing algorithm heap insertion simple must ensure heap order preserved insertion generally postinsertion operation insertingavalueintothenextfreeslotinanarrayissimple wejust needtokeeptrackofthenextfreeindexinthearrayasacounterandincrement insertion inserting value heap first part algorithmthesecondisvalidatingheaporder inthecaseofminheapordering requires u swap value parent child value child value parent must subtree containing value insertedchapter 4 heap 34 figure 43 converting tree data structure array counterpartchapter 4 heap 35 figure 44 calculating node property run time efficiency heap insertion olog n run time product verifying heap order first part algorithm actual insertion array o1 figure 45 show step inserting value 3 9 12 7 1 minheapchapter 4 heap 36 figure 45 inserting value minheapchapter 4 heap 37 1 algorithm addvalue 2 pre value value add heap 3 count number item heap 4 post value added heap 5 heapcount value 6 count count 1 7 minheapify 8 end add 1 algorithm minheapify 2 pre count number item heap 3 heap array used store heap item 4 post heap preserved min heap ordering 5 count 1 6 i0 heapi heapi12 7 swapheapi heapi12 8 i12 9 end 10 end minheapify design maxheapify algorithm similar min heapify algorithm difference operator second condition entering loop changed 42 deletion insertion deleting item involves ensuring heap ordering preserved algorithm deletion three step 1 find index value delete 2 put last value heap index location item delete 3 verify heap ordering subtree used include valuechapter 4 heap 38 1 algorithm removevalue 2 pre value value remove heap 3 left right updated alias 2index1 2index2 respectively 4 count number item heap 5 heap array used store heap item 6 post value located heap removed true otherwise false 7 step 1 8 index findindexheap value 9 index0 10 return false 11 end 12 count count 1 13 step 2 14 heapindex heapcount 15 step 3 16 left count heapindex heapleft heapindex heapright 17 promote smallest key subtree 18 heapleft heapright 19 swapheap left index 20 indexleft 21 else 22 swapheap right index 23 indexright 24 end 25 end 26 return true 27 end remove figure 46 show remove algorithm visually removing 1 heap containing value 1 3 9 12 13 figure 46 assume havespecifiedthatthebackingarrayoftheheapshouldhaveaninitialcapacity eight pleasenotethatinourdeletionalgorithmthatwedontdefaulttheremoved value heap array using heap reference type ie object thatareallocatedonaheapyouwillwanttofreethatmemory thisisimportant unmanaged managed language latter want null empty hole garbage collector reclaim memory null hole object could still reached thus wont garbage collected 43 searching searching heap merely matter traversing item heap array sequentially operation run time complexity search thought one us breadth first traversal defined 374 visit node within heap check presence specified itemchapter 4 heap 39 figure 46 deleting item heapchapter 4 heap 40 1 algorithm containsvalue 2 pre value value search heap 3 count number item heap 4 heap array used store heap item 5 post value located heap case true otherwise false 6 i0 7 count heapi cid54value 8 ii1 9 end 10 count 11 return true 12 else 13 return false 14 end 15 end contains problem previous algorithm dont take advantage property value heap hold property heap strategy used instance heap didnt contain value4wewouldhavetoexhaustthewholebackingheaparraybeforewecould determine wasnt present heap factoring know heap optimise search algorithm including logic make use property presented certain heap strategy optimising deterministically state value heap straightforward however problem interesting one example consideraminheapthatdoesntcontainthevalue5 wecanonlyrulethatthe value heap 5 parent current node inspected current node inspected node current level traversing case 5 heap provide answer without traversing rest heap property satisfied level node inspecting algorithm indeed fall back inspecting node heap optimisation present common feel extra logic within loop justified prevent expensive worse case run time thefollowingalgorithmisspecificallydesignedforaminheap totailorthe algorithmforamaxheapthetwocomparisonoperationsintheelseif condition within inner loop flippedchapter 4 heap 41 1 algorithm containsvalue 2 pre value value search heap 3 count number item heap 4 heap array used store heap item 5 post value located heap case true otherwise false 6 start0 7 nodes1 8 start count 9 startnodes1 10 endnodesstart 11 count0 12 start count startend 13 valueheapstart 14 return true 15 else value parentheapstart valueheapstart 16 countcount1 17 end 18 startstart1 19 end 20 countnodes 21 return false 22 end 23 nodesnodes2 24 end 25 return false 26 end contains new contains algorithm determines value heap checking whether count node event true confirm node n level ivalue parentn valuen thus isnopossiblewaythatvalueisintheheap asanexampleconsiderfigure47 searching value 10 within minheap displayed obvious dont need search whole heap determine 9 present verify traversing node second level heap previous expression defined hold true 44 traversal mentioned 43 traversal heap usually done like array data structure heap implementation based upon result traverse array starting initial array index 0 language visit value within array reached upper boundoftheheap youwillnotethatinthesearchalgorithmthatweusecount upper bound rather actual physical bound allocated array count used partition conceptual heap actual array implementation heap care item heap whole arraythe latter may contain various bit data result heap mutationchapter 4 heap 42 figure47 determining10isnotintheheapafterinspectingthenodesoflevel 2 figure 48 living dead space heap backing array followed advice gave deletion algorithm heap mutated several time contain form default value item longer heap potentially lengthofheaparraycount garbage value backing heap array data structure garbage value course vary platform platform make thing simple garbage value reference type simple 0 value type figure48showsaheapthatyoucanassumehasbeenmutatedmanytimes forthisexamplewecanfurtherassumethatatsomepointtheitemsinindexes 3 5 actually contained reference live object type figure 48 subscript used disambiguate separate object read thus far likely picked traversing heap order would little benefit heap property hold subtree node traversing heap fashion requires creative intervention heap usually traversed way one prescribed previously 45 summary heap commonly used implement priority queue see 62 sample implementation facilitate heap sort discussed insertion 41 deletion 42 section heap maintains heap order according selected ordering strategy strategy referred minheapchapter 4 heap 43 max heap former strategy enforces value parent node le child latter enforces value parent greater child whenyoucomeacrossaheapandyouarenottoldwhatstrategyitenforces assume us minheap strategy heap configured otherwise eg use maxheap often require state explicitly heap abides progressively strategy invocationoftheinsertionanddeletionalgorithms thecostofsuchapolicyis thatuponeachinsertionanddeletionweinvokealgorithmsthathavelogarithmic run time complexity cost maintaining strategy might seem overly expensive still come price also factor cost dynamic array expansion stage occur number item within heap outgrows space allocated heap backingarray itmaybeinyourbestinteresttoresearchagoodinitialstarting size heap array assist minimising impact dynamic array resizingchapter 5 set set contains number value particular order value within set distinct one another generally set implementation tend check value set adding avoiding issue repeated value ever occurring thissectiondoesnotcoversettheoryindepthratheritdemonstratesbriefly thewaysinwhichthevaluesofsetscanbedefinedandcommonoperationsthat may performed upon thenotationa479120definesasetawhosevaluesarelistedwithin curly brace given set defined previously say 4 member denoted 4a 99 member denoted 99 often defining set manually stating member tiresome importantly set may contain large number value concise way defining set member providing series property value set must satisfy example definition xx 0x 2 0 set contains positive integer even x alias current value inspecting right hand side property x must satisfy set example x must be0andtheremainderofthearithmeticexpressionx2mustbe0 youwill beabletonotefromthepreviousdefinitionofthesetathatthesetcancontain infinite number value value set even integersthatareamemberofthenaturalnumberssetnwheren123 finally brief introduction set cover set intersection union common operation amongst many others per formed set union set defined follows ab x x x b intersection ab x x x b figure 51 demonstrates set intersection union graphically giventhesetdefinitionsa123andb 629theunionofthetwo setsisab 12369andtheintersectionofthetwosetsisab 2 set union intersection sometimes provided within frame work associated mainstream language case net 351 algorithm exist extension method defined type sys temlinqenumerable2 result dsa provide implementation 1httpwwwmicrosoftcomnet 2httpmsdnmicrosoftcomenuslibrarysystemlinqenumerable_membersaspx 44chapter 5 set 45 figure 51 ab b ab algorithm algorithm defined systemlinqenumerable deal mainly sequence rather set exclusively setunioncanbeimplementedasasimpletraversalofbothsetsaddingeach item two set new union set 1 algorithm unionset1 set2 2 pre set1 set2cid54 3 union set 3 post union set1 set2 created 4 foreach item set1 5 unionadditem 6 end foreach 7 foreach item set2 8 unionadditem 9 end foreach 10 return union 11 end union run time union algorithm omn number item first set n number item second set runtime applies set exhibit o1 insertion set intersection also trivial implement major thing worth pointing algorithm traverse set containing fewest item exhausted item smaller two set item member set thus item add intersection setchapter 5 set 46 1 algorithm intersectionset1 set2 2 pre set1 set2cid54 3 intersection smallerset set 3 post intersection set1 set2 created 4 set1count set2count 5 smallersetset1 6 else 7 smallersetset2 8 end 9 foreach item smallerset 10 set1containsitem set2containsitem 11 intersectionadditem 12 end 13 end foreach 14 return intersection 15 end intersection run time intersection algorithm n number item smaller two set like union algorithm linear runtime attained operating set o1 insertion 51 unordered set general sense enforce explicit ordering mem bers example member b 629 conform ordering scheme required library provide implementation unordered set dsa simply mention disambiguate unordered set ordered set look insertion unordered set cover briefly hash table efficient data structure use implementation 511 insertion anunorderedsetcanbeefficientlyimplementedusingahashtableasitsbacking data structure mentioned previously add item set item already set backing data structure use must quick look insertion run time complexity hash map generally provides following 1 o1 insertion 2 approaching o1 look depends good hashing algorithm hash table hash table employ incredibly efficient general purpose hashing algorithm run time complexity hash table library choice similar term efficiencychapter 5 set 47 52 ordered ordered set similar unordered set sense member distinct ordered set enforces predefined comparison member produce set whose member ordered appropriately dsa 05 earlier used binary search tree defined 3 internal backing data structure ordered set version 06 onwards replaced binary search tree avl tree primarily avl balanced ordered set order realised performing inorder traversal upon backing tree data structure yield correct ordered sequence set member ordered set dsa simply wrapper avl tree additionally ensures tree contains unique item read 7 learn run time complexity associated operation 53 summary set provide way collection unique object either ordered unordered implementing set either ordered unordered key select correct backing data structure discussed 511 check first item already contained within set adding need check quick possible unordered set rely use hash table use key item determine whether alreadycontainedwithintheset usingahashtablethischeckresultsinanear constant run time complexity ordered set cost little check however logarithmic growth incur using binary search tree backing data structure acceptable anotherkeypropertyofsetsimplementedusingtheapproachwedescribeis favourably fast lookup time like check inser tionforahashtablethisruntimecomplexityshouldbenearconstant ordered set described 3 perform binary chop stage searching existence item yielding logarithmic run time wecanusesetstofacilitatemanyalgorithmsthatwouldotherwisebealittle le clear implementation example 114 use unordered set assist construction algorithm determines number repeated word within stringchapter 6 queue queue essential data structure found vast amount soft ware user mode kernel mode application core system fundamentally honour first first fifo strategy item first put queue first served second item added queue second served traditional queue allows access item front queue add item queue item placed back queue historically queue always following three core method enqueue place item back queue dequeue retrievestheitematthefrontofthequeueandremovesitfromthe queue peek 1 retrieves item front queue without removing queue asanexampletodemonstratethebehaviourofaqueuewewillwalkthrough ascenariowherebyweinvokeeachofthepreviouslymentionedmethodsobserv ing mutation upon queue data structure following list describes operation performed upon queue figure 61 1 enqueue10 2 enqueue12 3 enqueue9 4 enqueue8 5 enqueue3 6 dequeue 7 peek 1thisoperationissometimesreferredtoasfront 48chapter 6 queue 49 8 enqueue33 9 peek 10 dequeue 61 standard queue queue implicitly like described prior section dsa dont provide standard queue queue popular core data structure find pretty much every mainstream library provides queue data structure use language choice section discus required implement efficient queue data structure main property queue access item front queue queue data structure efficiently implemented using singly linked list defined 21 singly linked list provides o1 insertion deletion run time complexity reason o1 run timecomplexityfordeletionisbecauseweonlyeverremoveitemsfromthefront queue dequeue operation since always pointer item head singly linked list removal simply case returning value old head node modifying head pointer next node old head node run time complexity searching queue remains singly linked list 62 priority queue unlike standard queue item ordered term arrived first priority queue determines order item using form custom comparer see item highest priority item priorityqueuebeingorderedbypriorityitremainsthesameasanormalqueue access item front queue asensibleimplementationofapriorityqueueistouseaheapdatastructure definedin4 usingaheapwecanlookatthefirstiteminthequeuebysimply returningtheitematindex0withintheheaparray aheapprovidesuswiththe ability construct priority queue item highest priority either smallest value largest 63 double ended queue unlike queue talked previously chapter double ended queue allows access item front back queue adoubleendedqueueiscommonlyknownasadequewhichisthename refer deque applies prioritization strategy item like priority queue item added order either front back deque formerpropertiesofthedequearedenotedbytheprogrammerutilisingthedata structure exposed interfacechapter 6 queue 50 figure 61 queue mutationschapter 6 queue 51 dequesprovidefrontandbackspecificversionsofcommonqueueoperations eg may want enqueue item front queue rather back case would use method name along line enqueuefront following list identifies operation commonly supported deques enqueuefront enqueueback dequeuefront dequeueback peekfront peekback figure 62 show deque invocation following method order 1 enqueueback12 2 enqueuefront1 3 enqueueback23 4 enqueuefront908 5 dequeuefront 6 dequeueback operation onetoone translation term behaviour normal queue priority queue case set algorithm add item back deque may named normalqueueseg enqueueback maysimplybecalledenqueue ansoon frameworksalsospecifyexplicitbehavioursthatdatastructuresmustadhereto thisiscertainlythecaseinnetwheremostcollectionsimplementaninterface requires data structure expose standard add method scenario safely assume add method simply enqueue item back deque respect algorithmic run time complexity deque normal queue enqueueing item back queue o1 additionally enqueuing item front queue also o1 operation deque wrapper data structure us either array doubly linked list using array backing data structure would require pro grammer explicit size array front would provide anobviousadvantageiftheprogrammercoulddeterministicallystatethemaxi mum number item deque would contain one time unfortunately case doesnt hold result backing array inherently incur expense invoking resizing algorithm would likely operation approach would also leave library developerchapter 6 queue 52 figure 62 deque data structure several mutationschapter 6 queue 53 look array minimization technique well could several invocation resizing algorithm various mutation deque later array taking considerable amount memory yet using small percentage memory algorithm described would also yet invocation would harder gauge strategically bypass aforementioned issue deque typically us doubly linked list baking data structure node two pointer consumesmorememorythanitsarrayitemcounterpartitmakesredundantthe need expensive resizing algorithm data structure increase size dynamically language target garbage collected virtual machine memory reclamation opaque process node longer ref erenced become unreachable thus marked collection upon next invocation garbage collection algorithm c lan guagethatusesexplicitmemoryallocationanddeallocationitwillbeuptothe programmer decide memory store object freed 64 summary withnormalqueueswehaveseenthatthosewhoarrivefirstaredealtwithfirst dealt firstinfirstout fifo order queue ever useful example window cpu scheduler us different queue priority process determine next process utilise cpu specified time quantum normal queue constant insertion deletion run time searching queue fairly unusualtypically interested item front queue despite searching usually exposed queue typically run time linear chapter also seen priority queue front queue highest priority near back lowest one implementation priority queue use heap data structure backing store run time insertion deletion searching heap defined 4 queuesareaverynaturaldatastructureandwhiletheyarefairlyprimitive make many problem lot simpler example breadth first search defined 374 make extensive use queueschapter 7 avl tree early 60 gm adelsonvelsky em landis invented first self balancing binary search tree data structure calling avl tree anavltreeisabinarysearchtreebstdefinedin3withaselfbalancing condition stating difference height left right subtrees one see figure 71 condition restored tree modification force general shape avl tree continuing let u focus balance important consider binary search tree obtained starting empty tree inserting value following order 12345 bst figure 72 represents worst case scenario run ning time common operation search insertion deletion applying balance condition ensure worst case running time common operation olog n height avl tree n node olog n regardless order value inserted theavlbalanceconditionknownalsoasthenodebalancefactorrepresents additional piece information stored node combined technique efficiently restores balance condition tree avltreetheinventorsmakeuseofawellknowntechniquecalledtreerotation h h1 figure 71 left right subtrees avl tree differ height 1 54chapter 7 avl tree 55 1 2 3 4 5 figure 72 unbalanced binary search tree 2 4 1 4 2 5 3 5 1 3 b figure 73 avl tree insertion order a12345 b15432chapter 7 avl tree 56 71 tree rotation atreerotationisaconstanttimeoperationonabinarysearchtreethatchanges theshapeofatreewhilepreservingstandardbstproperties thereareleftand right rotation decrease height bst moving smaller subtrees larger subtrees 14 8 rightrotation 8 24 2 14 leftrotation 2 11 11 24 figure 74 tree left right rotationschapter 7 avl tree 57 1 algorithm leftrotationnode 2 pre noderight 3 post noderight new root subtree 4 node become noderights left child 5 bst property preserved 6 rightnode noderight 7 noderight rightnodeleft 8 rightnodeleft node 9 end leftrotation 1 algorithm rightrotationnode 2 pre nodeleft 3 post nodeleft new root subtree 4 node become nodelefts right child 5 bst property preserved 6 leftnode nodeleft 7 nodeleft leftnoderight 8 leftnoderight node 9 end rightrotation right left rotation algorithm symmetric pointer changed rotation resulting o1 runtime complexity field present node changed 72 tree rebalancing algorithm present section verifies left right subtrees differ height 1 property present perform correct rotation notice use two new algorithm represent double rotation algorithm named leftandrightrotation rightandleftrotation algorithm self documenting name eg leftandrightrotation first performs left rotation subsequently right rotationchapter 7 avl tree 58 1 algorithm checkbalancecurrent 2 pre current node start balancing 3 post current height updated tree balance needed 4 restored rotation 5 currentleft currentright 6 currentheight 1 7 else 8 currentheight maxheightcurrentleftheightcurrentright 1 9 end 10 heightcurrentleft heightcurrentright 1 11 heightcurrentleftleft heightcurrentleftright 0 12 rightrotationcurrent 13 else 14 leftandrightrotationcurrent 15 end 16 else heightcurrentleft heightcurrentright 1 17 heightcurrentrightleft heightcurrentrightright 0 18 leftrotationcurrent 19 else 20 rightandleftrotationcurrent 21 end 22 end 23 end checkbalance 73 insertion avl insertion operates first inserting given value way bst insertion applying rebalancing technique necessary latter isonlyperformediftheavlpropertynolongerholds thatistheleftandright subtrees height differ 1 time insert node avl tree 1 wegodownthetreetofindthecorrectpointatwhichtoinsertthenode manner bst insertion 2 travel tree inserted node check node balancing property violated property hasnt violated need rebalance tree opposite true balancing property violatedchapter 7 avl tree 59 1 algorithm insertvalue 2 pre value passed custom type check type 3 post value placed correct location tree 4 root 5 root nodevalue 6 else 7 insertnoderoot value 8 end 9 end insert 1 algorithm insertnodecurrent value 2 pre current node start 3 post value placed correct location tree 4 preserving tree balance 5 valuecurrentvalue 6 currentleft 7 currentleft nodevalue 8 else 9 insertnodecurrentleft value 10 end 11 else 12 currentright 13 currentright nodevalue 14 else 15 insertnodecurrentright value 16 end 17 end 18 checkbalancecurrent 19 end insertnode 74 deletion ourbalancingalgorithmisliketheonepresentedforourbstdefinedin33 major difference ensure tree still adheres avl balance property removal node tree doesnt need rebalanced value removing contained within tree step required however value tree removal upset avl balance property must perform correct rotationschapter 7 avl tree 60 1 algorithm removevalue 2 pre value value node remove root root node 3 avl 4 post node value removed tree rebalanced found 5 case yield true otherwise false 6 nodetoremoveroot 7 parent 8 stackpath root 9 nodetoremovecid54 nodetoremovevaluevalue 10 parent nodetoremove 11 valuenodetoremovevalue 12 nodetoremove nodetoremoveleft 13 else 14 nodetoremove nodetoremoveright 15 end 16 pathpushnodetoremove 17 end 18 nodetoremove 19 return false value avl 20 end 21 parent findparentvalue 22 count1 count keep track node avl 23 root removing node avl 24 else nodetoremoveleft nodetoremoveright null 25 case 1 26 nodetoremovevalue parentvalue 27 parentleft 28 else 29 parentright 30 end 31 else nodetoremoveleft nodetoremoveright cid54 32 case 2 33 nodetoremovevalue parentvalue 34 parentleft nodetoremoveright 35 else 36 parentright nodetoremoveright 37 end 38 else nodetoremoveleft cid54 nodetoremoveright 39 case 3 40 nodetoremovevalue parentvalue 41 parentleft nodetoremoveleft 42 else 43 parentright nodetoremoveleft 44 end 45 else 46 case 4 47 largestvaluenodetoremoveleft 48 largestvalueright cid54 49 find largest value left subtree nodetoremove 50 largestvaluelargestvaluerightchapter 7 avl tree 61 51 end 52 set parent right pointer largestvalue 53 findparentlargestvaluevalueright 54 nodetoremovevalue largestvaluevalue 55 end 56 pathcount0 57 checkbalancepathpop trackback root node check balance 58 end 59 countcount1 60 return true 61 end remove 75 summary avl tree sophisticated self balancing tree thought smarter younger brother binary search tree unlike older brother avl tree avoids worst case linear complexity runtimes operation avl tree guarantee via enforcement balancing algorithm left right subtrees differ height 1 yield logarithmic runtime complexitypart ii algorithm 62chapter 8 sorting sorting algorithm chapter use data structure specific type demonstrate sorting eg 32 bit integer often used associated operation eg etc clear behaviour algorithm discussed easily translated generic sorting algo rithms within respective language choice 81 bubble sort one simple form sorting comparing item every item list however description may imply form sorting particularly effecient on2 simple form bubble sort implemented two loop 1 algorithm bubblesortlist 2 pre list cid54 3 post list sorted value ascending order 4 i0 listcount1 5 j 0 listcount1 6 listilistj 7 swaplistilistj 8 end 9 end 10 end 11 return list 12 end bubblesort 82 merge sort merge sort algorithm fairly efficient space time complexity onlognandisfairlytrivialtoimplement thealgorithmisbasedonsplitting alistintotwosimilarsizedlistsleftandrightandsortingeachlistandthen merging sorted list back together note function mergeordered simply take two ordered list make one 63chapter 8 sorting 64 4 75 74 2 54 4 75 74 2 54 4 74 75 2 54 4 74 2 75 54 4 74 2 54 75 0 1 2 3 4 0 1 2 3 4 0 1 2 3 4 0 1 2 3 4 0 1 2 3 4 4 74 2 54 75 4 74 2 54 75 4 2 74 54 75 4 2 54 74 75 0 1 2 3 4 0 1 2 3 4 0 1 2 3 4 0 1 2 3 4 4 2 54 74 75 2 4 54 74 75 2 4 54 74 75 0 1 2 3 4 0 1 2 3 4 0 1 2 3 4 2 4 54 74 75 2 4 54 74 75 0 1 2 3 4 0 1 2 3 4 2 4 54 74 75 0 1 2 3 4 figure 81 bubble sort iteration 1 algorithm mergesortlist 2 pre list cid54 3 post list sorted value ascending order 4 listcount 1 already sorted 5 return list 6 end 7 mlistcount 2 8 left listm 9 right listlistcount 10 i0 leftcount1 11 lefti listi 12 end 13 i0 rightcount1 14 righti listi 15 end 16 left mergesortleft 17 right mergesortright 18 return mergeorderedleft right 19 end mergesortchapter 8 sorting 65 4 4 4 2 75 75 4 4 75 54 75 74 74 74 75 2 2 74 54 54 2 2 74 54 2 2 54 54 5 4 divide imperamerge figure 82 merge sort divide et impera approach 83 quick sort quick sort one popular sorting algorithm based divide et imperastrategyresultinginanonlog ncomplexity thealgorithmstartsby picking item called pivot moving smaller item greaterelementsafterit thisisthemainquicksortoperationcalledpartition recursively repeated lesser greater sub list size one zero case list implicitly sorted choosinganappropriatepivot asforexamplethemedianelementisfunda mental avoiding drastically reduced performance on2chapter 8 sorting 66 4 75 74 2 54 pivot 4 75 74 2 54 pivot 4 54 74 2 75 pivot 4 2 74 54 75 pivot 4 2 54 74 75 pivot 4 2 74 75 pivot pivot 2 4 74 75 pivot pivot 2 4 54 74 75 figure 83 quick sort example pivot median strategy 1 algorithm quicksortlist 2 pre list cid54 3 post list sorted value ascending order 4 listcount 1 already sorted 5 return list 6 end 7 pivotmedianvaluelist 8 i0 listcount1 9 listipivot 10 equalinsertlisti 11 end 12 listipivot 13 lessinsertlisti 14 end 15 listipivot 16 greaterinsertlisti 17 end 18 end 19 return concatenatequicksortless equal quicksortgreater 20 end quicksortchapter 8 sorting 67 84 insertion sort insertionsortisasomewhatinterestingalgorithmwithanexpensiveruntimeof on2 best thought sorting scheme similar sorting hand playing card ie take one card look rest intent building ordered set card hand 4 75 74 4 75 74 2 54 4 75 74 2 54 4 75 74 2 54 2 54 4 74 75 2 54 2 4 74 75 54 2 4 54 74 75 figure 84 insertion sort iteration 1 algorithm insertionsortlist 2 pre list cid54 3 post list sorted value ascending order 4 unsorted1 5 unsortedlistcount 6 holdlistunsorted 7 iunsorted1 8 i0 holdlisti 9 listi1 listi 10 ii1 11 end 12 listi1 hold 13 unsortedunsorted1 14 end 15 return list 16 end insertionsortchapter 8 sorting 68 85 shell sort put simply shell sort thought efficient variation insertion sort described 84 achieves mainly comparing item varying distance apart resulting run time complexity log2 n shell sort fairly straight forward may seem somewhat confusing first differs sorting algorithm way selects item compare figure 85 show shell sort ran array integer red coloured square current value holding 1 algorithm shellsortlist 2 pre list cid54 3 post list sorted value ascending order 4 incrementlistcount 2 5 increment cid540 6 currentincrement 7 currentlistcount 8 holdlistcurrent 9 icurrentincrement 10 i0 holdlisti 11 listiincrement listi 12 iincrement 13 end 14 listiincrement hold 15 currentcurrent1 16 end 17 increment 2 18 end 19 return list 20 end shellsort 86 radix sort unlike sorting algorithm described previously radix sort us bucket sort item bucket hold item particular property called key normally bucket queue time radix sort performed bucket emptied starting smallest key bucket largest looking itemswithinalisttosortwedosobyisolatingaspecifickeyeg intheexample show maximum three key item highest key need look hundred dealing example base 10 number one point 10 possible key value 09 bucket show first simple version radix sort let u clarify mean isolating key given number 102 look first key one see two progressing next key ten see number zero finally see number single hundred number used example total three keyschapter 8 sorting 69 figure 85 shell sortchapter 8 sorting 70 1 one 2 ten 3 hundred forfurtherclarificationwhatifwewantedtodeterminehowmanythousands number 102 clearly none often looking number final like often obvious asked question many thousand 102 simply pad number zero location eg 0102 obvious key value thousand location zero last thing identify actually show simple implemen tation radix sort work positive integer requires specify maximum key size list need way isolate specific key one time solution actually simple often want isolate key number spell clearly key accessed integer following expression key number keytoaccess 10 simple example let say want access ten key number 1290 ten column key 10 substitution yield key 1290 10 10 9 next key lookatforanumbercanbeattainedbymultiplyingthelastkeybytenworking left right sequential manner value key used following algorithmtoworkouttheindexofanarrayofqueuestoenqueuetheiteminto 1 algorithm radixlist maxkeysize 2 pre list cid54 3 maxkeysize0 represents largest key size list 4 post list sorted 5 queue queue10 6 indexofkey 1 7 fori0 maxkeysize1 8 foreach item list 9 queuesgetqueueindexitem indexofkeyenqueueitem 10 end foreach 11 list collapsequeuesqueues 12 clearqueuesqueues 13 indexofkey indexofkey10 14 end 15 return list 16 end radix figure86showsthemembersofqueuesfromthealgorithmdescribedabove operating list whose member 90128791123 61 key interested number highlighted omitted queue figure 86 mean contain item 87 summary throughout chapter seen many different algorithm sorting list efficient eg quick sort defined 83 egchapter 8 sorting 71 figure 86 radix sort base 10 algorithm bubble sort defined 81 selectingthecorrectsortingalgorithmisusuallydenotedpurelybyefficiency eg would always choose merge sort shell sort also factor look though based actual imple mentation algorithm nicely expressed recursive fashion howeverthesealgorithmsoughttobeprettyefficienteg implementingalinear quadratic slower algorithm using recursion would bad idea want learn careful implementing recursive algorithm see appendix cchapter 9 numeric unless stated otherwise alias n denotes standard 32 bit integer 91 primality test simple algorithm determines whether given integer prime number eg 2 5 7 13 prime number however 6 result product two number 6 attempt slow inner loop n used upper bound 1 algorithm isprimen 2 post n determined prime 3 i2 n 4 j 1 sqrtn 5 ij n 6 return false 7 end 8 end 9 end 10 end isprime 92 base conversion dsa contains number algorithm convert base 10 number equivalent binary octal hexadecimal form example 78 binary 10 representation 1001110 2 table 91 show algorithm trace number convert binary 742 10 72chapter 9 numeric 73 1 algorithm tobinaryn 2 pre n0 3 post n converted base 2 representation 4 n0 5 listaddn 2 6 nn2 7 end 8 return reverselist 9 end tobinary n list 742 0 371 01 185 011 92 0110 46 01101 23 011011 11 0110111 5 01101111 2 011011110 1 0110111101 table 91 algorithm trace tobinary 93 attaining greatest common denomina tor two number afairlyroutineprobleminmathematicsisthatoffindingthegreatestcommon denominatoroftwointegerswhatweareessentiallyafteristhegreatestnumber multiple eg greatest common denominator 9 15 3 one elegant solution problem based euclid algorithm run time complexity on2 1 algorithm greatestcommondenominatorm n 2 pre n integer 3 post greatest common denominator two integer calculated 4 n0 5 return 6 end 7 return greatestcommondenominatorn n 8 end greatestcommondenominatorchapter 9 numeric 74 94 computing maximum value num ber specific base consisting n digit algorithm computes maximum value number given number digit eg using base 10 system maximum number made 4 digit number 9999 similarly maximum number 10 consists 4 digit base 2 number 1111 15 2 10 expression compute maximum value n digit bn 1 previous expression b number base n numberofdigits asanexampleifwewantedtodeterminethemaximumvalue hexadecimal number base 16 consisting 6 digit expression would follows 1661 maximum value previous example would represented ffffff yield 16777215 16 10 following algorithm numberbase considered restricted value 2 8 9 16 reason actual implementation numberbase enumeration type base enumeration type defined basebinary 2octal8decimal10hexadecimal16 thereasonweprovidethedefinitionof base istogiveyouanideahowthis algorithmcanbemodelledinamorereadablemannerratherthanusingvarious checkstodeterminethecorrectbasetouse forourimplementationwecastthe valueofnumberbasetoanintegerassuchweextractthevalueassociatedwith relevant option base enumeration example cast theoptionoctal toanintegerwewouldgetthevalue8 inthealgorithmlisted cast implicit use actual argument numberbase 1 algorithm maxvaluenumberbase n 2 pre numberbase number system use n number digit 3 post maximum value numberbase consisting n digit computed 4 return powernumberbasen 1 5 end maxvalue 95 factorial number attainingthefactorialofanumberisaprimitivemathematicaloperation many implementation factorial algorithm recursive problem cursive nature however present iterative solution iterative solution presented trivial implement doesnt suffer use recursion recursion see c thefactorialof0and1is0 theaforementionedactsasabasecasethatwe build upon factorial 2 2 factorial 1 similarly factorial 3 3 factorial 2 indicate factorial number using form n n number wish attain factorial algorithm doesnt use notation handy knowchapter 9 numeric 75 1 algorithm factorialn 2 pre n0 n number compute factorial 3 post factorial n computed 4 n2 5 return 1 6 end 7 factorial1 8 i2 n 9 factorialfactoriali 10 end 11 return factorial 12 end factorial 96 summary chapter presented several numeric algorithm simply fun design perhaps message reader gain chapter algorithm applied several domain make work respective domain attainable numeric algorithmsinparticulardrivesomeofthemostadvancedsystemsontheplanet computing data weather forecastschapter 10 searching 101 sequential search simple algorithm search specific item inside list operates looping element match occurs end reached 1 algorithm sequentialsearchlist item 2 pre list cid54 3 post return index item found otherwise 1 4 index0 5 indexlistcount listindex cid54 item 6 indexindex1 7 end 8 indexlistcount listindex item 9 return index 10 end 11 return 1 12 end sequentialsearch 102 probability search probability search statistical sequential searching algorithm addition searching item take account frequency swapping predecessor list algorithm complexity still remains inanonuniformitemssearchthemorefrequentitemsareinthefirstpositions reducing list scanning time figure 101 show resulting state list searching two item notice searched item search probability increased search operation respectively 76chapter 10 searching 77 figure 101 search12 b search101 1 algorithm probabilitysearchlist item 2 pre list cid54 3 post boolean indicating item found former case swap founded item predecessor 4 index0 5 indexlistcount listindex cid54 item 6 indexindex1 7 end 8 indexlistcount listindex cid54 item 9 return false 10 end 11 index0 12 swaplistindexlistindex1 13 end 14 return true 15 end probabilitysearch 103 summary chapter presented novel searching algorithm presented efficient searching algorithm earlier like instance logarithmic searching algorithm avl bst tree use defined 32 decided cover searching algorithm known binary chop another name binary search binary chop usually refers array counterpart aschapter 10 searching 78 reader already seen algorithm 3 searching algorithm efficiency largely depends underlying data structure used store data instance quicker deter minewhetheranitemisinahashtablethanitisanarraysimilarlyitisquicker tosearchabstthanitisalinkedlist ifyouaregoingtosearchfordatafairly oftenthenwestronglyadvisethatyousitdownandresearchthedatastructures available case using list primarily linear data structure lack knowledge model data research data structure best fit scenariochapter 11 string string chapter text purely string operation transformation incredibly frequent within program algorithm presented based problem author come across previously formulated satisfy curiosity 111 reversing order word sentence defining algorithm primitive string operation simple eg extracting substring string however algorithm require inventiveness little tricky algorithm presented simply reverse character string rather revers order word within string algorithm work principal word delimited white space using marker define word start end easily reverse 79chapter 11 string 80 1 algorithm reversewordsvalue 2 pre value cid54 sb string buffer 3 post word value reversed 4 lastvaluelength 1 5 startlast 6 last0 7 skip whitespace 8 start0 valuestart whitespace 9 startstart1 10 end 11 laststart 12 march index beginning word 13 start0 start cid54 whitespace 14 startstart1 15 end 16 append char start1 length1 string buffer sb 17 istart1 last 18 sbappendvaluei 19 end 20 isnt last word string add whitespace word buffer 21 start0 22 sbappend 23 end 24 laststart1 25 startlast 26 end 27 check added one many whitespace sb 28 sbsblength 1 whitespace 29 cut whitespace 30 sblength sblength 1 31 end 32 return sb 33 end reversewords 112 detecting palindrome although frequent algorithm applied reallife scenario detecting palindrome fun turn pretty trivial algorithm design algorithm present run time complexity algo rithmusestwopointersatoppositeendsofstringwearecheckingisapalindrome pointer march towards always checking charactertheypointtoisthesamewithrespecttovalue figure111showsthe ispalindrome algorithminoperationonthestringwasiteliotstoiletisaw remove punctuation white space aforementioned string find valid palindromechapter 11 string 81 figure 111 left right pointer marching towards one another 1 algorithm ispalindromevalue 2 pre value cid54 3 post value determined palindrome 4 wordvaluestriptouppercase 5 left0 6 rightwordlength 1 7 wordleft wordright leftright 8 leftleft1 9 rightright1 10 end 11 return wordleft wordright 12 end ispalindrome ispalindrome algorithm call method name strip algorithmdiscardspunctuationinthestringincludingwhitespace asaresult word contains heavily compacted representation original string character uppercase representation palindromesdiscardwhitespacepunctuationandcasemakingthesechanges allowsustodesignasimplealgorithmwhilemakingouralgorithmfairlyrobust respect palindrome detect 113 counting number word string countingthenumberofwordsinastringcanseemprettytrivialatfirsthowever case need aware 1 tracking string 2 updating word count correct place 3 skipping white space delimits word asanexampleconsiderthestringbenatehayclearlythisstringcontains three word distinguished via white space previously listed point managed using three variable 1 index 2 wordcount 3 inwordchapter 11 string 82 figure 112 string three word figure 113 string varying number white space delimiting word previously listed index keep track current index thestring wordcountisanintegerthatkeepstrackofthenumberofwordswe encountered finally inword boolean flag denotes whether present time within word currently hitting white space word opposite true present index hitting white space denotes word algorithm word separated one occurrence white space dont take account particular splitting symbol may use eg net stringsplit1 take char array character determines delimiter use split character within string chunk string resulting array substring infigure112wepresentastringindexedasanarray typicallythepattern word delimited single occurrence white space figure 113 show string number word varying white space splitting 1httpmsdnmicrosoftcomenuslibrarysystemstringsplitaspxchapter 11 string 83 1 algorithm wordcountvalue 2 pre value cid54 3 post number word contained within value determined 4 inwordtrue 5 wordcount0 6 index0 7 skip initial white space 8 valueindex whitespace indexvaluelength 1 9 indexindex1 10 end 11 string whitespace 12 indexvaluelength valueindex whitespace 13 return 0 14 end 15 indexvaluelength 16 valueindex whitespace 17 skip whitespace 18 valueindex whitespace indexvaluelength 1 19 indexindex1 20 end 21 inwordfalse 22 wordcountwordcount1 23 else 24 inwordtrue 25 end 26 indexindex1 27 end 28 last word may followed whitespace 29 inword 30 wordcountwordcount1 31 end 32 return wordcount 33 end wordcount 114 determining number repeated word within string help unordered set algorithm split word within string using specified delimiter algorithm straightforward implement split word using single occurrence white space delimiter get word within string back element array iterate word adding set containsonlyuniquestringswecanattainthenumberofuniquewordsfromthe string left subtract unique word count total number sting contained array returned split operation split operation refer mentioned 113chapter 11 string 84 figure 114 undesired uniques set b desired uniques set 1 algorithm repeatedwordcountvalue 2 pre value cid54 3 post number repeated word value returned 4 wordsvaluesplit 5 uniques set 6 foreach word word 7 uniquesaddwordstrip 8 end foreach 9 return wordslength uniquescount 10 end repeatedwordcount notice repeatedwordcount algorithm use strip method referred earlier 111 simply remove punctuation word reason perform operation word build accurate unique string collection eg test test arethesamewordminusthepunctuation figure114showstheundesiredand desired set unique set respectively 115 determining first matching character two string thealgorithmtodeterminewhetheranycharacterofastringmatchesanyofthe charactersinanotherstringisprettytrivial putsimplywecanparsethestrings considered using double loop check discarding punctuation equality character thus returning nonnegative index represents location first character match figure 115 otherwise return 1 match occurs approach exhibit run time complexity on2chapter 11 string 85 word e e e 0 1 2 3 4 0 1 2 3 4 0 1 2 3 4 index index index match p e r p e r p e r 0 1 2 3 4 5 6 0 1 2 3 4 5 6 0 1 2 3 4 5 6 b c figure 115 first step b second step c match occurred 1 algorithm anywordmatch 2 pre wordmatch cid54 3 post index representing match location occured 1 otherwise 4 i0 wordlength1 5 wordi whitespace 6 ii1 7 end 8 index0 matchlength1 9 matchindex whitespace 10 indexindex1 11 end 12 matchindex wordi 13 return index 14 end 15 end 16 end 17 return 1 18 end 116 summary hope reader seen fun algorithm string data type string probably common data type data structure rememberwearedealingwithanarraythatyouwillworkwithsoitsimportant learn creative one find string fascinating simple google search string nuance language encoding provide great number problem spurred alongalittlewithourintroductoryalgorithmsyoucandevisesomeofyourownappendix algorithm walkthrough learning design good algorithm assisted greatly using structuredapproachtotracingitsbehaviour inmostcasestracinganalgorithm requires single table case tracing enough also want use diagram data structure algorithm operates diagram used visualise problem effectively seeing thing visually help understand problem quicker better thetracetablewillstoreinformationaboutthevariablesusedinyouralgo rithm value within table constantly updated algorithm mutates approach allows attain history various value variable held may also able infer pattern value variable contained make algorithm efficient found approach simple powerful combining visual representation problem well history past value generated algorithm make understanding solving problem much easier chapter show work iterative recursive algorithm using technique outlined a1 iterative algorithm trace ispalindrome algorithm defined 112 example iterative walkthrough even look variable algorithm us first look actual data structure algorithm operates pretty obvious operating string represented string essentially block contiguous memory consists char data type one character string accessed via index much like would accessing item within array picture presenting string thought array character example use ispalindrome operate string never odd even know string data structure represented value string operate let go ahead draw shown figure a1 86appendix algorithm walkthrough 87 figure a1 visualising data structure operating value word left right table a1 column variable wish track theispalindrome algorithmusesthefollowinglistofvariablesinsomeform throughout execution 1 value 2 word 3 left 4 right identified value variable need keep track simply create column table shown table a1 using ispalindrome algorithm execute statement updating variable value table appropriately table a2 show final table value variable used ispalindrome respectively approach may look little bloated print paper much compact string table annotate string array index aid algorithm walkthrough one point clarify time whether include variable change time trace table table a2 included value word variable convenient may find want promote value larger diagram like figure a1 use trace table variable whose value change algorithm recommend promote core data structure operated larger diagram outside table interrogate easily value word left right never odd even neveroddoreven 0 13 1 12 2 11 3 10 4 9 5 8 6 7 7 6 table a2 algorithm trace ispalindromeappendix algorithm walkthrough 88 stress enough important trace designing algorithm use trace table verify algorithm correctness cost simple table quick sketch data structure operatingonyoucandevisecorrectalgorithmsquicker visualisingtheproblem domainandkeepingtrackofchangingdatamakesproblemsaloteasiertosolve moreover always point reference look back a2 recursive algorithm part working recursive algorithm simple walking iterative algorithm one thing need keep track though method call return recursive algorithm much simple follow draw recursive call rather using table based approach section use recursive implementation algorithm computes number fiboncacci sequence 1 algorithm fibonaccin 2 pre n number fibonacci sequence compute 3 post fibonacci sequence number n computed 4 n1 5 return 0 6 else n2 7 return 1 8 end 9 return fibonaccin1 fibonaccin2 10 end fibonacci jump showing diagrammtic representation algo rithm call fibonacci algorithm briefly talk case algorithm algorithm three case total 1 n1 2 n2 3 n2 thefirsttwoitemsinthepreceedinglistarethebasecasesofthealgorithm hit one base case recursive method call tree wont return anything third item list recursive case call recursive case etch ever closer one base case figurea2showsadiagrammticrepresentationoftherecursivecallchain figure a2 order method called labelled figure a3 show call chain annotated return value method call well order method return caller figure a3 return value represented annotation red arrow important note recursive call ever return caller upon hitting one two base case eventually hit base case branch recursive call cease upon hitting base case go back toappendix algorithm walkthrough 89 figure a2 call chain fibonacci algorithm figure a3 return chain fibonacci algorithmappendix algorithm walkthrough 90 caller continue execution method execution caller contiued next statement expression recursive call made fibonacci algorithm recursive case make two recursive call first recursive call fibonaccin1 return caller execute second recursive call fibonaccin2 recursive call returned caller caller subesequently return caller recursive algorithm much easier demonstrate diagrammatically figure a2 demonstrates come across recursive algorithm draw method call diagram understand algorithm work high level a3 summary understandingalgorithmscanbehardattimesparticularlyfromanimplemen tation perspective order understand algorithm try work using trace table case algorithm also recursive sketch recursive call visualise callreturn chain vast majority case implementing algorithm simple provided know algorithm work mastering algorithm work high level key devising well designed solution problem handappendix b translation walkthrough conversion pseudo actual imperative language usually straight forward clarify example provided example convert algorithm 91 c language 1 public static bool isprimeint number 2 3 number 2 4 5 return false 6 7 int innerloopbound intmathfloormathsqrtnumber 8 int 1 number 9 10 forint j 1 j innerloopbound j 11 12 j number 13 14 return false 15 16 17 18 return true 19 part conversion straight forward process however may inject various call utility algorithm ascertain correct result consideration take note many algorithm fairly strict precondition may several scenario need toinjectthecorrectcodetohandlesuchsituationstopreservethecorrectnessof algorithm precondition suitably handled throwing correct exception 91appendix b translation walkthrough 92 b1 summary asyoucanseefromtheexampleusedinthischapterwehavetriedtomakethe translation pseudo code algorithm mainstream imperative language simple possible whenever encounter keyword within pseudo code example unfamiliar browse appendix e descirbes key wordappendix c recursive v iterative solution one succinct property modern programming language like c c java well many others language allow define method reference method said recursive oneofthebiggestadvantagesrecursivemethodsbringtothetableis usually result readable compact solution problem recursive method one defined term generally recursive algorithm two main property 1 one base case 2 recursive case fornowwewillbrieflycoverthesetwoaspectsofrecursivealgorithms recursive call making progress base case otherwise going run trouble trouble speak manifest typically stack overflow describe later briefly described recursive algorithm might want use approach algorithm talk iterative solution iterative solution us recursion whatsoever iterative solution relies use loop eg dowhile etc side iterative algorithm tend clear recursive counterpart respect operation major advantage iterative solution speed production software find us little recursive algorithm whatsoever latter property sometimes company prerequisite checking code eg upon checking static analysis tool may verify code developer checking containsnorecursivealgorithms normallyitissystemslevelcodethathasthis zero tolerance policy recursive algorithm using recursion always reserved fast algorithm avoid following algorithm run time deficiency 1 on2 2 on3 93appendix c recursive v iterative solution 94 3 o2n ifyouuserecursionforalgorithmswithanyoftheaboveruntimeefficiencys inviting trouble growth rate algorithm high case algorithm lean heavily technique like divide conquer constantly splitting problem smaller problem good practice case going spawning lot method call overhead method call dont come cheap soon pile either cause algorithm run lot slower expected worse run stack space exceed allotted stack space thread process shutdown operating system case irrespective oftheplatformyouuseeg netornativecetc youcanaskforabigger stacksize butyoutypicallyonlywanttodothisifyouhaveaverygoodreason c1 activation record activation record created every time invoke method put simply activation record something put stack support method invocation activation record take small amount time create pretty lightweight normally activation record method call follows general actual parameter method pushed onto stack return address pushed onto stack topofstack index incremented total amount memory required local variable within method jump made method many recursive algorithm operating large data structure algo rithms inefficient run stack space quickly consider algorithm invoked given specific value creates many recursive call case big chunk stack consumed wait activation record start unwound nested method inthecallchainexitandreturntotheirrespectivecaller whenamethodexits activation record unwound unwinding activation record result several step 1 topofstack index decremented total amount memory consumed method 2 return address popped stack 3 topofstack index decremented total amount memory consumed actual parametersappendix c recursive v iterative solution 95 activation record efficient way support method call build quickly recursive algorithm exhaust stack size allocated thread fairly fast given chance justaboutnowweshouldbedustingthecobwebsofftheageoldexampleof iterative v recursive solution form fibonacci algorithm famous example highlight beauty pitfall recursive algorithm iterative solution pretty self documenting job lot quicker give fibonacci algorithm input say 60 would wait get value back ogn run time iterative version hand run time dont let put recursion example mainly used shock programmer thinking ramification recursion rather warning c2 problem recursive nature something may come across data structure algo rithms actually recursive nature perfect example tree data structure common tree node usually contains value along two point er two node node type see tree recursive makeup wit node possibly pointing two node using recursive algorithm tree make sense simply adhering inherent design data structure operating course good news still bound limitation mentioned previously chapter wecanalsolookatsortingalgorithmslikemergesort andquicksort algorithm recursive design make sense model recursively c3 summary recursion powerful tool one programmer know often software project take trade readability efficiency case recursion great provided dont go use implement algorithm quadratic run time higher course rule thumb u throwing caution wind defensive coding always prevail many time recursion natural home recursive data structure algorithm recursive nature using recursion scenario perfectly acceptable using recursion something like linked list traversal little overkill iterative counterpart probably le line code recursive counterpart talk implication using recursion abstract point view consult compiler run time environ ment detail may case compiler recognises thing like tail recursion optimise isnt unheard fact commercial compiler amount optimisation compiler canappendix c recursive v iterative solution 96 though somewhat limited fact still using recursion developer accept certain accountability performanceappendix testing testing essential part software development testing often discarded many developer belief burden proof software within company hold test centric role couldnt truth developer least provide suite unit test verify certain boundary condition software agreatthingabouttestingisthatyoubuildupprogressivelyasafetynet youaddortweakalgorithmsandthenrunyoursuiteoftestsyouwillbequickly alertedtoanycasesthatyouhavebrokenwithyourrecentchanges suchasuite oftestsinanysizeableprojectisabsolutelyessentialtomaintainingafairlyhigh bar come quality course order attain standard need think carefully test construct unit testing subject vast majority chapter arewidelyavailableonmostplatforms mostmodernlanguageslikecc java offer impressive catalogue testing framework use unit testing following list identifies testing framework popular junit targeted jav httpwwwjunitorg nunit used language target microsofts common language runtime httpwwwnunitorgindexphp boost test library targetedatc thetestlibrarythatshipswiththeincrediblypopular boostlibraries httpwwwboostorg adirectlinktothelibrariesdoc umentationhttpwwwboostorgdoclibs1_36_0libstestdoc htmlindexhtml cppunit targeted c httpcppunitsourceforgenet dont worry think list sparse far offer listed one listed testing framework believe popular c c java d1 constitutes unit test aunittestshouldfocusonasingleatomicpropertyofthesubjectbeingtested try test many thing result suite somewhat 97appendix testing 98 unstructured test example wanting write test verified particular value v returned specific input test smallest amount work possible verify v correct given unit test simple self describing aswellasaunittestbeingrelativelyatomicyoushouldalsomakesurethat unit test execute quickly imagine future may haveatestsuiteconsistingofthousandsoftestsyouwantthoseteststoexecute quickly possible failure attain goal likely result thesuiteoftestsnotbeingranthatoftenbythedevelopersonyourteam occur number reason main one would becomes incredibly tedious waiting several minute run test developer local machine building test suite help greatly team scenario particularly using continuous build server scenario suite test devised developer tester ran part build process employingsuchstrategiescanhelpyoucatchnigglinglittleerrorcasesearly rather via customer base nothing embarrassing developer trivial bug code reported customer d2 write test source great debate would understatement personify ques tion recent year test driven approach development become popular approach known test driven development commonly acronym tdd one founding principle tdd write unit test first watch fail make pas premise ever write enoughcodeatanyonetimetosatisfythestatebasedassertionsmadeinaunit test found approach provide structured intent implementation algorithm one stage single goal makethefailingtestpass becausetddmakesyouwritethetestsupfrontyou neverfindyourselfinasituationwhereyouforgetorcantbebotheredtowrite test code often case write test coded implementation author book use tdd preferred method aswehavealreadymentionedthattddisourfavouredapproachtotesting would somewhat injustice list describe mantra often associate red signifies test failed green failing test pass refactor restructure program make sense easier maintain thefirstpointoftheabovelistalwaysoccursatleastoncemoreifyoucount build error tdd initially task stage solely make testpassthatistomaketherespectivetestgreen thelastitemisbasedaroundappendix testing 99 restructuring program make readable maintainable possible thelastpointisveryimportantastddisaprogressivemethodology building solution adhere progressive revision algorithm restructuringwhenappropriateyouwillfindthatusingtddyoucanimplement cleanly structured type d3 seriously view test suite test major part project ecosystem treated amount respect production code range fromcorrectandcleancodeformattingtothetestingcodebeingstoredwithin source control repository employing methodology like tdd testing implementing find spend great amount time writing test thus treated differently production code test clearly named fully documented intent d4 three nowthatyouhaveasenseoftheimportanceofyourtestsuiteyouwillinevitably wanttoknowhowtoactuallystructureeachblockofimperativeswithinasingle unit test popular approach three described following list assemble create object require order perform state based asser tions act invoke respective operation object assembled mutate state desired assertion assert specify expect hold previous two step following example show simple test method employ three public void mytest assemble type new type act tmethoda assert assertistruetboolexpr d5 structuring test structuring test viewed upon structuring pro duction code eg unit test person type may contained withinappendix testing 100 persontest type typically test abstracted production code test disjoint production code may two dynamiclinklibrariesdllthefirstcontainingtheproductioncodethesecond containing test code also use thing like inheritance etc defining class test point test code much like production code apply amount thought structure would production code d6 code coverage something get product unit testing code coverage statistic codecoverageismerelyanindicatorastotheportionsofproduction codethatyourunitstestscover usingtdditislikelythatyourcodecoverage high although vary depending easy use tdd within project d7 summary testing key creation moderately stable product moreover unit testingcanbeusedtocreateasafetyblanketwhenaddingandremovingfeatures providing early warning breaking change within production codeappendix e symbol definition throughoutthepseudocodelistingsyouwillfindseveralsymbolsuseddescribes meaning symbol symbol description assignment equality le equal le greater equal greater cid54 inequality null logical logical whitespace single occurrence whitespace yield like return build sequence table e1 pseudo symbol definition symbol direct translation vast majority imperative counterpart 101